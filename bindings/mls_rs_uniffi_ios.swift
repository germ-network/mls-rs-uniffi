// This file was autogenerated by some hot garbage in the `uniffi` crate.
// Trust me, you don't want to mess with it!

// swiftlint:disable all
import Foundation

// Depending on the consumer's build setup, the low-level FFI code
// might be in a separate module, or it might be compiled inline into
// this module. This is a bit of light hackery to work with both.
#if canImport(mls_rs_uniffi_iosFFI)
import mls_rs_uniffi_iosFFI
#endif

fileprivate extension RustBuffer {
    // Allocate a new buffer, copying the contents of a `UInt8` array.
    init(bytes: [UInt8]) {
        let rbuf = bytes.withUnsafeBufferPointer { ptr in
            RustBuffer.from(ptr)
        }
        self.init(capacity: rbuf.capacity, len: rbuf.len, data: rbuf.data)
    }

    static func empty() -> RustBuffer {
        RustBuffer(capacity: 0, len:0, data: nil)
    }

    static func from(_ ptr: UnsafeBufferPointer<UInt8>) -> RustBuffer {
        try! rustCall { ffi_mls_rs_uniffi_ios_rustbuffer_from_bytes(ForeignBytes(bufferPointer: ptr), $0) }
    }

    // Frees the buffer in place.
    // The buffer must not be used after this is called.
    func deallocate() {
        try! rustCall { ffi_mls_rs_uniffi_ios_rustbuffer_free(self, $0) }
    }
}

fileprivate extension ForeignBytes {
    init(bufferPointer: UnsafeBufferPointer<UInt8>) {
        self.init(len: Int32(bufferPointer.count), data: bufferPointer.baseAddress)
    }
}

// For every type used in the interface, we provide helper methods for conveniently
// lifting and lowering that type from C-compatible data, and for reading and writing
// values of that type in a buffer.

// Helper classes/extensions that don't change.
// Someday, this will be in a library of its own.

fileprivate extension Data {
    init(rustBuffer: RustBuffer) {
        self.init(
            bytesNoCopy: rustBuffer.data!,
            count: Int(rustBuffer.len),
            deallocator: .none
        )
    }
}

// Define reader functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.
//
// With external types, one swift source file needs to be able to call the read
// method on another source file's FfiConverter, but then what visibility
// should Reader have?
// - If Reader is fileprivate, then this means the read() must also
//   be fileprivate, which doesn't work with external types.
// - If Reader is internal/public, we'll get compile errors since both source
//   files will try define the same type.
//
// Instead, the read() method and these helper functions input a tuple of data

fileprivate func createReader(data: Data) -> (data: Data, offset: Data.Index) {
    (data: data, offset: 0)
}

// Reads an integer at the current offset, in big-endian order, and advances
// the offset on success. Throws if reading the integer would move the
// offset past the end of the buffer.
fileprivate func readInt<T: FixedWidthInteger>(_ reader: inout (data: Data, offset: Data.Index)) throws -> T {
    let range = reader.offset..<reader.offset + MemoryLayout<T>.size
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    if T.self == UInt8.self {
        let value = reader.data[reader.offset]
        reader.offset += 1
        return value as! T
    }
    var value: T = 0
    let _ = withUnsafeMutableBytes(of: &value, { reader.data.copyBytes(to: $0, from: range)})
    reader.offset = range.upperBound
    return value.bigEndian
}

// Reads an arbitrary number of bytes, to be used to read
// raw bytes, this is useful when lifting strings
fileprivate func readBytes(_ reader: inout (data: Data, offset: Data.Index), count: Int) throws -> Array<UInt8> {
    let range = reader.offset..<(reader.offset+count)
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    var value = [UInt8](repeating: 0, count: count)
    value.withUnsafeMutableBufferPointer({ buffer in
        reader.data.copyBytes(to: buffer, from: range)
    })
    reader.offset = range.upperBound
    return value
}

// Reads a float at the current offset.
fileprivate func readFloat(_ reader: inout (data: Data, offset: Data.Index)) throws -> Float {
    return Float(bitPattern: try readInt(&reader))
}

// Reads a float at the current offset.
fileprivate func readDouble(_ reader: inout (data: Data, offset: Data.Index)) throws -> Double {
    return Double(bitPattern: try readInt(&reader))
}

// Indicates if the offset has reached the end of the buffer.
fileprivate func hasRemaining(_ reader: (data: Data, offset: Data.Index)) -> Bool {
    return reader.offset < reader.data.count
}

// Define writer functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.  See the above discussion on Readers for details.

fileprivate func createWriter() -> [UInt8] {
    return []
}

fileprivate func writeBytes<S>(_ writer: inout [UInt8], _ byteArr: S) where S: Sequence, S.Element == UInt8 {
    writer.append(contentsOf: byteArr)
}

// Writes an integer in big-endian order.
//
// Warning: make sure what you are trying to write
// is in the correct type!
fileprivate func writeInt<T: FixedWidthInteger>(_ writer: inout [UInt8], _ value: T) {
    var value = value.bigEndian
    withUnsafeBytes(of: &value) { writer.append(contentsOf: $0) }
}

fileprivate func writeFloat(_ writer: inout [UInt8], _ value: Float) {
    writeInt(&writer, value.bitPattern)
}

fileprivate func writeDouble(_ writer: inout [UInt8], _ value: Double) {
    writeInt(&writer, value.bitPattern)
}

// Protocol for types that transfer other types across the FFI. This is
// analogous to the Rust trait of the same name.
fileprivate protocol FfiConverter {
    associatedtype FfiType
    associatedtype SwiftType

    static func lift(_ value: FfiType) throws -> SwiftType
    static func lower(_ value: SwiftType) -> FfiType
    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType
    static func write(_ value: SwiftType, into buf: inout [UInt8])
}

// Types conforming to `Primitive` pass themselves directly over the FFI.
fileprivate protocol FfiConverterPrimitive: FfiConverter where FfiType == SwiftType { }

extension FfiConverterPrimitive {
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lift(_ value: FfiType) throws -> SwiftType {
        return value
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lower(_ value: SwiftType) -> FfiType {
        return value
    }
}

// Types conforming to `FfiConverterRustBuffer` lift and lower into a `RustBuffer`.
// Used for complex types where it's hard to write a custom lift/lower.
fileprivate protocol FfiConverterRustBuffer: FfiConverter where FfiType == RustBuffer {}

extension FfiConverterRustBuffer {
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lift(_ buf: RustBuffer) throws -> SwiftType {
        var reader = createReader(data: Data(rustBuffer: buf))
        let value = try read(from: &reader)
        if hasRemaining(reader) {
            throw UniffiInternalError.incompleteData
        }
        buf.deallocate()
        return value
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lower(_ value: SwiftType) -> RustBuffer {
          var writer = createWriter()
          write(value, into: &writer)
          return RustBuffer(bytes: writer)
    }
}
// An error type for FFI errors. These errors occur at the UniFFI level, not
// the library level.
fileprivate enum UniffiInternalError: LocalizedError {
    case bufferOverflow
    case incompleteData
    case unexpectedOptionalTag
    case unexpectedEnumCase
    case unexpectedNullPointer
    case unexpectedRustCallStatusCode
    case unexpectedRustCallError
    case unexpectedStaleHandle
    case rustPanic(_ message: String)

    public var errorDescription: String? {
        switch self {
        case .bufferOverflow: return "Reading the requested value would read past the end of the buffer"
        case .incompleteData: return "The buffer still has data after lifting its containing value"
        case .unexpectedOptionalTag: return "Unexpected optional tag; should be 0 or 1"
        case .unexpectedEnumCase: return "Raw enum value doesn't match any cases"
        case .unexpectedNullPointer: return "Raw pointer value was null"
        case .unexpectedRustCallStatusCode: return "Unexpected RustCallStatus code"
        case .unexpectedRustCallError: return "CALL_ERROR but no errorClass specified"
        case .unexpectedStaleHandle: return "The object in the handle map has been dropped already"
        case let .rustPanic(message): return message
        }
    }
}

fileprivate extension NSLock {
    func withLock<T>(f: () throws -> T) rethrows -> T {
        self.lock()
        defer { self.unlock() }
        return try f()
    }
}

fileprivate let CALL_SUCCESS: Int8 = 0
fileprivate let CALL_ERROR: Int8 = 1
fileprivate let CALL_UNEXPECTED_ERROR: Int8 = 2
fileprivate let CALL_CANCELLED: Int8 = 3

fileprivate extension RustCallStatus {
    init() {
        self.init(
            code: CALL_SUCCESS,
            errorBuf: RustBuffer.init(
                capacity: 0,
                len: 0,
                data: nil
            )
        )
    }
}

private func rustCall<T>(_ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    let neverThrow: ((RustBuffer) throws -> Never)? = nil
    return try makeRustCall(callback, errorHandler: neverThrow)
}

private func rustCallWithError<T, E: Swift.Error>(
    _ errorHandler: @escaping (RustBuffer) throws -> E,
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    try makeRustCall(callback, errorHandler: errorHandler)
}

private func makeRustCall<T, E: Swift.Error>(
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T,
    errorHandler: ((RustBuffer) throws -> E)?
) throws -> T {
    uniffiEnsureMlsRsUniffiIosInitialized()
    var callStatus = RustCallStatus.init()
    let returnedVal = callback(&callStatus)
    try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: errorHandler)
    return returnedVal
}

private func uniffiCheckCallStatus<E: Swift.Error>(
    callStatus: RustCallStatus,
    errorHandler: ((RustBuffer) throws -> E)?
) throws {
    switch callStatus.code {
        case CALL_SUCCESS:
            return

        case CALL_ERROR:
            if let errorHandler = errorHandler {
                throw try errorHandler(callStatus.errorBuf)
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.unexpectedRustCallError
            }

        case CALL_UNEXPECTED_ERROR:
            // When the rust code sees a panic, it tries to construct a RustBuffer
            // with the message.  But if that code panics, then it just sends back
            // an empty buffer.
            if callStatus.errorBuf.len > 0 {
                throw UniffiInternalError.rustPanic(try FfiConverterString.lift(callStatus.errorBuf))
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.rustPanic("Rust panic")
            }

        case CALL_CANCELLED:
            fatalError("Cancellation not supported yet")

        default:
            throw UniffiInternalError.unexpectedRustCallStatusCode
    }
}

private func uniffiTraitInterfaceCall<T>(
    callStatus: UnsafeMutablePointer<RustCallStatus>,
    makeCall: () throws -> T,
    writeReturn: (T) -> ()
) {
    do {
        try writeReturn(makeCall())
    } catch let error {
        callStatus.pointee.code = CALL_UNEXPECTED_ERROR
        callStatus.pointee.errorBuf = FfiConverterString.lower(String(describing: error))
    }
}

private func uniffiTraitInterfaceCallWithError<T, E>(
    callStatus: UnsafeMutablePointer<RustCallStatus>,
    makeCall: () throws -> T,
    writeReturn: (T) -> (),
    lowerError: (E) -> RustBuffer
) {
    do {
        try writeReturn(makeCall())
    } catch let error as E {
        callStatus.pointee.code = CALL_ERROR
        callStatus.pointee.errorBuf = lowerError(error)
    } catch {
        callStatus.pointee.code = CALL_UNEXPECTED_ERROR
        callStatus.pointee.errorBuf = FfiConverterString.lower(String(describing: error))
    }
}
fileprivate final class UniffiHandleMap<T>: @unchecked Sendable {
    // All mutation happens with this lock held, which is why we implement @unchecked Sendable.
    private let lock = NSLock()
    private var map: [UInt64: T] = [:]
    private var currentHandle: UInt64 = 1

    func insert(obj: T) -> UInt64 {
        lock.withLock {
            let handle = currentHandle
            currentHandle += 1
            map[handle] = obj
            return handle
        }
    }

     func get(handle: UInt64) throws -> T {
        try lock.withLock {
            guard let obj = map[handle] else {
                throw UniffiInternalError.unexpectedStaleHandle
            }
            return obj
        }
    }

    @discardableResult
    func remove(handle: UInt64) throws -> T {
        try lock.withLock {
            guard let obj = map.removeValue(forKey: handle) else {
                throw UniffiInternalError.unexpectedStaleHandle
            }
            return obj
        }
    }

    var count: Int {
        get {
            map.count
        }
    }
}


// Public interface members begin here.


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterUInt8: FfiConverterPrimitive {
    typealias FfiType = UInt8
    typealias SwiftType = UInt8

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt8 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: UInt8, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterUInt16: FfiConverterPrimitive {
    typealias FfiType = UInt16
    typealias SwiftType = UInt16

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt16 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterUInt32: FfiConverterPrimitive {
    typealias FfiType = UInt32
    typealias SwiftType = UInt32

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt32 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterUInt64: FfiConverterPrimitive {
    typealias FfiType = UInt64
    typealias SwiftType = UInt64

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt64 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterBool : FfiConverter {
    typealias FfiType = Int8
    typealias SwiftType = Bool

    public static func lift(_ value: Int8) throws -> Bool {
        return value != 0
    }

    public static func lower(_ value: Bool) -> Int8 {
        return value ? 1 : 0
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bool {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Bool, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterString: FfiConverter {
    typealias SwiftType = String
    typealias FfiType = RustBuffer

    public static func lift(_ value: RustBuffer) throws -> String {
        defer {
            value.deallocate()
        }
        if value.data == nil {
            return String()
        }
        let bytes = UnsafeBufferPointer<UInt8>(start: value.data!, count: Int(value.len))
        return String(bytes: bytes, encoding: String.Encoding.utf8)!
    }

    public static func lower(_ value: String) -> RustBuffer {
        return value.utf8CString.withUnsafeBufferPointer { ptr in
            // The swift string gives us int8_t, we want uint8_t.
            ptr.withMemoryRebound(to: UInt8.self) { ptr in
                // The swift string gives us a trailing null byte, we don't want it.
                let buf = UnsafeBufferPointer(rebasing: ptr.prefix(upTo: ptr.count - 1))
                return RustBuffer.from(buf)
            }
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> String {
        let len: Int32 = try readInt(&buf)
        return String(bytes: try readBytes(&buf, count: Int(len)), encoding: String.Encoding.utf8)!
    }

    public static func write(_ value: String, into buf: inout [UInt8]) {
        let len = Int32(value.utf8.count)
        writeInt(&buf, len)
        writeBytes(&buf, value.utf8)
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterData: FfiConverterRustBuffer {
    typealias SwiftType = Data

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Data {
        let len: Int32 = try readInt(&buf)
        return Data(try readBytes(&buf, count: Int(len)))
    }

    public static func write(_ value: Data, into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        writeBytes(&buf, value)
    }
}




/**
 * An MLS client used to create key packages and manage groups.
 *
 * See [`mls_rs::Client`] for details.
 */
public protocol ClientFfiProtocol: AnyObject {
    
    /**
     * Create and immediately join a new group.
     *
     * If a group ID is not given, the underlying library will create
     * a unique ID for you.
     *
     * See [`mls_rs::Client::create_group`] and
     * [`mls_rs::Client::create_group_with_id`] for details.
     */
    func createGroup(groupId: Data?) throws  -> GroupFfi
    
    /**
     * Generate a new key package for this client.
     *
     * The key package is represented in is MLS message form. It is
     * needed when joining a group and can be published to a server
     * so other clients can look it up.
     *
     * See [`mls_rs::Client::generate_key_package_message`] for
     * details.
     */
    func generateKeyPackageMessage() throws  -> MessageFfi
    
    /**
     * Join an existing group.
     *
     * You must supply `ratchet_tree` if the client that created
     * `welcome_message` did not set `use_ratchet_tree_extension`.
     *
     * This variant doesn't support an imported ratched tree
     *
     * See [`mls_rs::Client::join_group`] for details.
     */
    func joinGroup(welcomeMessage: MessageFfi) throws  -> JoinInfo
    
    /**
     * Load an existing group.
     *
     * See [`mls_rs::Client::load_group`] for details.
     */
    func loadGroup(groupId: Data) throws  -> GroupFfi
    
    func signingIdentity() throws  -> SigningIdentityFfi
    
}
/**
 * An MLS client used to create key packages and manage groups.
 *
 * See [`mls_rs::Client`] for details.
 */
open class ClientFfi: ClientFfiProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_mls_rs_uniffi_ios_fn_clone_clientffi(self.pointer, $0) }
    }
    /**
     * Create a new client.
     *
     * The user is identified by `id`, which will be used to create a
     * basic credential together with the signature keypair.
     *
     * See [`mls_rs::Client::builder`] for details.
     */
public convenience init(id: Data, signatureKeypair: SignatureKeypair, clientConfig: ClientConfigFfi) {
    let pointer =
        try! rustCall() {
    uniffi_mls_rs_uniffi_ios_fn_constructor_clientffi_new(
        FfiConverterData.lower(id),
        FfiConverterTypeSignatureKeypair_lower(signatureKeypair),
        FfiConverterTypeClientConfigFFI_lower(clientConfig),$0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_mls_rs_uniffi_ios_fn_free_clientffi(pointer, $0) }
    }

    

    
    /**
     * Create and immediately join a new group.
     *
     * If a group ID is not given, the underlying library will create
     * a unique ID for you.
     *
     * See [`mls_rs::Client::create_group`] and
     * [`mls_rs::Client::create_group_with_id`] for details.
     */
open func createGroup(groupId: Data?)throws  -> GroupFfi  {
    return try  FfiConverterTypeGroupFFI_lift(try rustCallWithError(FfiConverterTypeMlSrsError_lift) {
    uniffi_mls_rs_uniffi_ios_fn_method_clientffi_create_group(self.uniffiClonePointer(),
        FfiConverterOptionData.lower(groupId),$0
    )
})
}
    
    /**
     * Generate a new key package for this client.
     *
     * The key package is represented in is MLS message form. It is
     * needed when joining a group and can be published to a server
     * so other clients can look it up.
     *
     * See [`mls_rs::Client::generate_key_package_message`] for
     * details.
     */
open func generateKeyPackageMessage()throws  -> MessageFfi  {
    return try  FfiConverterTypeMessageFFI_lift(try rustCallWithError(FfiConverterTypeMlSrsError_lift) {
    uniffi_mls_rs_uniffi_ios_fn_method_clientffi_generate_key_package_message(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Join an existing group.
     *
     * You must supply `ratchet_tree` if the client that created
     * `welcome_message` did not set `use_ratchet_tree_extension`.
     *
     * This variant doesn't support an imported ratched tree
     *
     * See [`mls_rs::Client::join_group`] for details.
     */
open func joinGroup(welcomeMessage: MessageFfi)throws  -> JoinInfo  {
    return try  FfiConverterTypeJoinInfo_lift(try rustCallWithError(FfiConverterTypeMlSrsError_lift) {
    uniffi_mls_rs_uniffi_ios_fn_method_clientffi_join_group(self.uniffiClonePointer(),
        FfiConverterTypeMessageFFI_lower(welcomeMessage),$0
    )
})
}
    
    /**
     * Load an existing group.
     *
     * See [`mls_rs::Client::load_group`] for details.
     */
open func loadGroup(groupId: Data)throws  -> GroupFfi  {
    return try  FfiConverterTypeGroupFFI_lift(try rustCallWithError(FfiConverterTypeMlSrsError_lift) {
    uniffi_mls_rs_uniffi_ios_fn_method_clientffi_load_group(self.uniffiClonePointer(),
        FfiConverterData.lower(groupId),$0
    )
})
}
    
open func signingIdentity()throws  -> SigningIdentityFfi  {
    return try  FfiConverterTypeSigningIdentityFFI_lift(try rustCallWithError(FfiConverterTypeMlSrsError_lift) {
    uniffi_mls_rs_uniffi_ios_fn_method_clientffi_signing_identity(self.uniffiClonePointer(),$0
    )
})
}
    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeClientFFI: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ClientFfi

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ClientFfi {
        return ClientFfi(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ClientFfi) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ClientFfi {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ClientFfi, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeClientFFI_lift(_ pointer: UnsafeMutableRawPointer) throws -> ClientFfi {
    return try FfiConverterTypeClientFFI.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeClientFFI_lower(_ value: ClientFfi) -> UnsafeMutableRawPointer {
    return FfiConverterTypeClientFFI.lower(value)
}






/**
 * A [`mls_rs::Extension`] wrapper.
 */
public protocol ExtensionFfiProtocol: AnyObject {
    
}
/**
 * A [`mls_rs::Extension`] wrapper.
 */
open class ExtensionFfi: ExtensionFfiProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_mls_rs_uniffi_ios_fn_clone_extensionffi(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_mls_rs_uniffi_ios_fn_free_extensionffi(pointer, $0) }
    }

    

    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeExtensionFFI: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ExtensionFfi

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ExtensionFfi {
        return ExtensionFfi(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ExtensionFfi) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ExtensionFfi {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ExtensionFfi, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeExtensionFFI_lift(_ pointer: UnsafeMutableRawPointer) throws -> ExtensionFfi {
    return try FfiConverterTypeExtensionFFI.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeExtensionFFI_lower(_ value: ExtensionFfi) -> UnsafeMutableRawPointer {
    return FfiConverterTypeExtensionFFI.lower(value)
}






/**
 * A [`mls_rs::ExtensionList`] wrapper.
 */
public protocol ExtensionListFfiProtocol: AnyObject {
    
}
/**
 * A [`mls_rs::ExtensionList`] wrapper.
 */
open class ExtensionListFfi: ExtensionListFfiProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_mls_rs_uniffi_ios_fn_clone_extensionlistffi(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_mls_rs_uniffi_ios_fn_free_extensionlistffi(pointer, $0) }
    }

    

    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeExtensionListFFI: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ExtensionListFfi

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ExtensionListFfi {
        return ExtensionListFfi(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ExtensionListFfi) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ExtensionListFfi {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ExtensionListFfi, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeExtensionListFFI_lift(_ pointer: UnsafeMutableRawPointer) throws -> ExtensionListFfi {
    return try FfiConverterTypeExtensionListFFI.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeExtensionListFFI_lower(_ value: ExtensionListFfi) -> UnsafeMutableRawPointer {
    return FfiConverterTypeExtensionListFFI.lower(value)
}






/**
 * An MLS end-to-end encrypted group.
 *
 * The group is used to send and process incoming messages and to
 * add/remove users.
 *
 * See [`mls_rs::Group`] for details.
 */
public protocol GroupFfiProtocol: AnyObject {
    
    /**
     * Commit the addition of one or more members.
     *
     * The members are representated by key packages. The result is
     * the welcome messages to send to the new members.
     *
     * See [`mls_rs::group::CommitBuilder::add_member`] for details.
     */
    func addMembers(keyPackages: [MessageFfi]) throws  -> CommitOutputFfi
    
    /**
     * Perform a commit of received proposals (or an empty commit).
     *
     * TODO: ensure `path_required` is always set in
     * [`MlsRules::commit_options`](`mls_rs::MlsRules::commit_options`).
     *
     * Returns the resulting commit message. See
     * [`mls_rs::Group::commit`] for details.
     */
    func commit() throws  -> CommitOutputFfi
    
    func currentEpoch()  -> UInt64
    
    func currentMemberIndex()  -> UInt32
    
    /**
     * Encrypt an application message using the current group state.
     *
     * An application message is an application-specific payload,
     * e.g., an UTF-8 encoded text message in a chat app. The
     * encoding is not determined by MLS and applications will have
     * to implement their own mechanism for how to agree on the
     * content encoding.
     *
     * The other group members will find the message in
     * [`ReceivedMessage::ApplicationMessage`] after calling
     * [`Group::process_incoming_message`].
     */
    func encryptApplicationMessage(message: Data, authenticatedData: Data, allowSelfProposals: Bool) throws  -> MessageFfi
    
    func exportSecret(label: Data, context: Data, len: UInt64) throws  -> Data
    
    func groupId()  -> Data
    
    func memberAtIndex(index: UInt32)  -> MlsMemberFfi?
    
    func members()  -> [MlsMemberFfi]
    
    /**
     * Process an inbound message for this group.
     */
    func processIncomingMessage(message: MessageFfi) throws  -> ReceivedMessageFfi
    
    func proposeUpdate(signer: SignatureSecretKeyFfi?, signingIdentity: SigningIdentityFfi?, authenticatedData: Data) throws  -> MessageFfi
    
    /**
     * Write the current state of the group to storage defined by
     * [`ClientConfig::group_state_storage`]
     */
    func writeToStorage() throws 
    
}
/**
 * An MLS end-to-end encrypted group.
 *
 * The group is used to send and process incoming messages and to
 * add/remove users.
 *
 * See [`mls_rs::Group`] for details.
 */
open class GroupFfi: GroupFfiProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_mls_rs_uniffi_ios_fn_clone_groupffi(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_mls_rs_uniffi_ios_fn_free_groupffi(pointer, $0) }
    }

    

    
    /**
     * Commit the addition of one or more members.
     *
     * The members are representated by key packages. The result is
     * the welcome messages to send to the new members.
     *
     * See [`mls_rs::group::CommitBuilder::add_member`] for details.
     */
open func addMembers(keyPackages: [MessageFfi])throws  -> CommitOutputFfi  {
    return try  FfiConverterTypeCommitOutputFFI_lift(try rustCallWithError(FfiConverterTypeMlSrsError_lift) {
    uniffi_mls_rs_uniffi_ios_fn_method_groupffi_add_members(self.uniffiClonePointer(),
        FfiConverterSequenceTypeMessageFFI.lower(keyPackages),$0
    )
})
}
    
    /**
     * Perform a commit of received proposals (or an empty commit).
     *
     * TODO: ensure `path_required` is always set in
     * [`MlsRules::commit_options`](`mls_rs::MlsRules::commit_options`).
     *
     * Returns the resulting commit message. See
     * [`mls_rs::Group::commit`] for details.
     */
open func commit()throws  -> CommitOutputFfi  {
    return try  FfiConverterTypeCommitOutputFFI_lift(try rustCallWithError(FfiConverterTypeMlSrsError_lift) {
    uniffi_mls_rs_uniffi_ios_fn_method_groupffi_commit(self.uniffiClonePointer(),$0
    )
})
}
    
open func currentEpoch() -> UInt64  {
    return try!  FfiConverterUInt64.lift(try! rustCall() {
    uniffi_mls_rs_uniffi_ios_fn_method_groupffi_current_epoch(self.uniffiClonePointer(),$0
    )
})
}
    
open func currentMemberIndex() -> UInt32  {
    return try!  FfiConverterUInt32.lift(try! rustCall() {
    uniffi_mls_rs_uniffi_ios_fn_method_groupffi_current_member_index(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Encrypt an application message using the current group state.
     *
     * An application message is an application-specific payload,
     * e.g., an UTF-8 encoded text message in a chat app. The
     * encoding is not determined by MLS and applications will have
     * to implement their own mechanism for how to agree on the
     * content encoding.
     *
     * The other group members will find the message in
     * [`ReceivedMessage::ApplicationMessage`] after calling
     * [`Group::process_incoming_message`].
     */
open func encryptApplicationMessage(message: Data, authenticatedData: Data, allowSelfProposals: Bool)throws  -> MessageFfi  {
    return try  FfiConverterTypeMessageFFI_lift(try rustCallWithError(FfiConverterTypeMlSrsError_lift) {
    uniffi_mls_rs_uniffi_ios_fn_method_groupffi_encrypt_application_message(self.uniffiClonePointer(),
        FfiConverterData.lower(message),
        FfiConverterData.lower(authenticatedData),
        FfiConverterBool.lower(allowSelfProposals),$0
    )
})
}
    
open func exportSecret(label: Data, context: Data, len: UInt64)throws  -> Data  {
    return try  FfiConverterData.lift(try rustCallWithError(FfiConverterTypeMlSrsError_lift) {
    uniffi_mls_rs_uniffi_ios_fn_method_groupffi_export_secret(self.uniffiClonePointer(),
        FfiConverterData.lower(label),
        FfiConverterData.lower(context),
        FfiConverterUInt64.lower(len),$0
    )
})
}
    
open func groupId() -> Data  {
    return try!  FfiConverterData.lift(try! rustCall() {
    uniffi_mls_rs_uniffi_ios_fn_method_groupffi_group_id(self.uniffiClonePointer(),$0
    )
})
}
    
open func memberAtIndex(index: UInt32) -> MlsMemberFfi?  {
    return try!  FfiConverterOptionTypeMLSMemberFFI.lift(try! rustCall() {
    uniffi_mls_rs_uniffi_ios_fn_method_groupffi_member_at_index(self.uniffiClonePointer(),
        FfiConverterUInt32.lower(index),$0
    )
})
}
    
open func members() -> [MlsMemberFfi]  {
    return try!  FfiConverterSequenceTypeMLSMemberFFI.lift(try! rustCall() {
    uniffi_mls_rs_uniffi_ios_fn_method_groupffi_members(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Process an inbound message for this group.
     */
open func processIncomingMessage(message: MessageFfi)throws  -> ReceivedMessageFfi  {
    return try  FfiConverterTypeReceivedMessageFFI_lift(try rustCallWithError(FfiConverterTypeMlSrsError_lift) {
    uniffi_mls_rs_uniffi_ios_fn_method_groupffi_process_incoming_message(self.uniffiClonePointer(),
        FfiConverterTypeMessageFFI_lower(message),$0
    )
})
}
    
open func proposeUpdate(signer: SignatureSecretKeyFfi?, signingIdentity: SigningIdentityFfi?, authenticatedData: Data)throws  -> MessageFfi  {
    return try  FfiConverterTypeMessageFFI_lift(try rustCallWithError(FfiConverterTypeMlSrsError_lift) {
    uniffi_mls_rs_uniffi_ios_fn_method_groupffi_propose_update(self.uniffiClonePointer(),
        FfiConverterOptionTypeSignatureSecretKeyFFI.lower(signer),
        FfiConverterOptionTypeSigningIdentityFFI.lower(signingIdentity),
        FfiConverterData.lower(authenticatedData),$0
    )
})
}
    
    /**
     * Write the current state of the group to storage defined by
     * [`ClientConfig::group_state_storage`]
     */
open func writeToStorage()throws   {try rustCallWithError(FfiConverterTypeMlSrsError_lift) {
    uniffi_mls_rs_uniffi_ios_fn_method_groupffi_write_to_storage(self.uniffiClonePointer(),$0
    )
}
}
    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeGroupFFI: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = GroupFfi

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> GroupFfi {
        return GroupFfi(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: GroupFfi) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> GroupFfi {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: GroupFfi, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeGroupFFI_lift(_ pointer: UnsafeMutableRawPointer) throws -> GroupFfi {
    return try FfiConverterTypeGroupFFI.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeGroupFFI_lower(_ value: GroupFfi) -> UnsafeMutableRawPointer {
    return FfiConverterTypeGroupFFI.lower(value)
}






public protocol GroupStateStorageProtocol: AnyObject {
    
    func state(groupId: Data) throws  -> Data?
    
    func epoch(groupId: Data, epochId: UInt64) throws  -> Data?
    
    func write(groupId: Data, groupState: Data, epochInserts: [EpochRecordFfi], epochUpdates: [EpochRecordFfi]) throws 
    
    func maxEpochId(groupId: Data) throws  -> UInt64?
    
}
open class GroupStateStorageProtocolImpl: GroupStateStorageProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_mls_rs_uniffi_ios_fn_clone_groupstatestorageprotocol(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_mls_rs_uniffi_ios_fn_free_groupstatestorageprotocol(pointer, $0) }
    }

    

    
open func state(groupId: Data)throws  -> Data?  {
    return try  FfiConverterOptionData.lift(try rustCallWithError(FfiConverterTypeMlSrsError_lift) {
    uniffi_mls_rs_uniffi_ios_fn_method_groupstatestorageprotocol_state(self.uniffiClonePointer(),
        FfiConverterData.lower(groupId),$0
    )
})
}
    
open func epoch(groupId: Data, epochId: UInt64)throws  -> Data?  {
    return try  FfiConverterOptionData.lift(try rustCallWithError(FfiConverterTypeMlSrsError_lift) {
    uniffi_mls_rs_uniffi_ios_fn_method_groupstatestorageprotocol_epoch(self.uniffiClonePointer(),
        FfiConverterData.lower(groupId),
        FfiConverterUInt64.lower(epochId),$0
    )
})
}
    
open func write(groupId: Data, groupState: Data, epochInserts: [EpochRecordFfi], epochUpdates: [EpochRecordFfi])throws   {try rustCallWithError(FfiConverterTypeMlSrsError_lift) {
    uniffi_mls_rs_uniffi_ios_fn_method_groupstatestorageprotocol_write(self.uniffiClonePointer(),
        FfiConverterData.lower(groupId),
        FfiConverterData.lower(groupState),
        FfiConverterSequenceTypeEpochRecordFFI.lower(epochInserts),
        FfiConverterSequenceTypeEpochRecordFFI.lower(epochUpdates),$0
    )
}
}
    
open func maxEpochId(groupId: Data)throws  -> UInt64?  {
    return try  FfiConverterOptionUInt64.lift(try rustCallWithError(FfiConverterTypeMlSrsError_lift) {
    uniffi_mls_rs_uniffi_ios_fn_method_groupstatestorageprotocol_max_epoch_id(self.uniffiClonePointer(),
        FfiConverterData.lower(groupId),$0
    )
})
}
    

}
// Magic number for the Rust proxy to call using the same mechanism as every other method,
// to free the callback once it's dropped by Rust.
private let IDX_CALLBACK_FREE: Int32 = 0
// Callback return codes
private let UNIFFI_CALLBACK_SUCCESS: Int32 = 0
private let UNIFFI_CALLBACK_ERROR: Int32 = 1
private let UNIFFI_CALLBACK_UNEXPECTED_ERROR: Int32 = 2

// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceGroupStateStorageProtocol {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    //
    // This creates 1-element array, since this seems to be the only way to construct a const
    // pointer that we can pass to the Rust code.
    static let vtable: [UniffiVTableCallbackInterfaceGroupStateStorageProtocol] = [UniffiVTableCallbackInterfaceGroupStateStorageProtocol(
        state: { (
            uniffiHandle: UInt64,
            groupId: RustBuffer,
            uniffiOutReturn: UnsafeMutablePointer<RustBuffer>,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> Data? in
                guard let uniffiObj = try? FfiConverterTypeGroupStateStorageProtocol.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try uniffiObj.state(
                     groupId: try FfiConverterData.lift(groupId)
                )
            }

            
            let writeReturn = { uniffiOutReturn.pointee = FfiConverterOptionData.lower($0) }
            uniffiTraitInterfaceCallWithError(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn,
                lowerError: FfiConverterTypeMlSrsError_lower
            )
        },
        epoch: { (
            uniffiHandle: UInt64,
            groupId: RustBuffer,
            epochId: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<RustBuffer>,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> Data? in
                guard let uniffiObj = try? FfiConverterTypeGroupStateStorageProtocol.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try uniffiObj.epoch(
                     groupId: try FfiConverterData.lift(groupId),
                     epochId: try FfiConverterUInt64.lift(epochId)
                )
            }

            
            let writeReturn = { uniffiOutReturn.pointee = FfiConverterOptionData.lower($0) }
            uniffiTraitInterfaceCallWithError(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn,
                lowerError: FfiConverterTypeMlSrsError_lower
            )
        },
        write: { (
            uniffiHandle: UInt64,
            groupId: RustBuffer,
            groupState: RustBuffer,
            epochInserts: RustBuffer,
            epochUpdates: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterTypeGroupStateStorageProtocol.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try uniffiObj.write(
                     groupId: try FfiConverterData.lift(groupId),
                     groupState: try FfiConverterData.lift(groupState),
                     epochInserts: try FfiConverterSequenceTypeEpochRecordFFI.lift(epochInserts),
                     epochUpdates: try FfiConverterSequenceTypeEpochRecordFFI.lift(epochUpdates)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCallWithError(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn,
                lowerError: FfiConverterTypeMlSrsError_lower
            )
        },
        maxEpochId: { (
            uniffiHandle: UInt64,
            groupId: RustBuffer,
            uniffiOutReturn: UnsafeMutablePointer<RustBuffer>,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> UInt64? in
                guard let uniffiObj = try? FfiConverterTypeGroupStateStorageProtocol.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try uniffiObj.maxEpochId(
                     groupId: try FfiConverterData.lift(groupId)
                )
            }

            
            let writeReturn = { uniffiOutReturn.pointee = FfiConverterOptionUInt64.lower($0) }
            uniffiTraitInterfaceCallWithError(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn,
                lowerError: FfiConverterTypeMlSrsError_lower
            )
        },
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            let result = try? FfiConverterTypeGroupStateStorageProtocol.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface GroupStateStorageProtocol: handle missing in uniffiFree")
            }
        }
    )]
}

private func uniffiCallbackInitGroupStateStorageProtocol() {
    uniffi_mls_rs_uniffi_ios_fn_init_callback_vtable_groupstatestorageprotocol(UniffiCallbackInterfaceGroupStateStorageProtocol.vtable)
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeGroupStateStorageProtocol: FfiConverter {
    fileprivate static let handleMap = UniffiHandleMap<GroupStateStorageProtocol>()

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = GroupStateStorageProtocol

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> GroupStateStorageProtocol {
        return GroupStateStorageProtocolImpl(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: GroupStateStorageProtocol) -> UnsafeMutableRawPointer {
        guard let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: handleMap.insert(obj: value))) else {
            fatalError("Cast to UnsafeMutableRawPointer failed")
        }
        return ptr
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> GroupStateStorageProtocol {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: GroupStateStorageProtocol, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeGroupStateStorageProtocol_lift(_ pointer: UnsafeMutableRawPointer) throws -> GroupStateStorageProtocol {
    return try FfiConverterTypeGroupStateStorageProtocol.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeGroupStateStorageProtocol_lower(_ value: GroupStateStorageProtocol) -> UnsafeMutableRawPointer {
    return FfiConverterTypeGroupStateStorageProtocol.lower(value)
}






/**
 * Identity system that can be used to validate a
 * [`SigningIdentity`](mls-rs-core::identity::SigningIdentity)
 */
public protocol IdentityProviderProtocol: AnyObject {
    
    /**
     * Determine if `signing_identity` is valid for a group member.
     *
     * A `timestamp` value can optionally be supplied to aid with validation
     * of a [`Credential`](mls-rs-core::identity::Credential) that requires
     * time based context. For example, X.509 certificates can become expired.
     */
    func validateMember(signingIdentity: SigningIdentityFfi, timestamp: UInt64?, context: MemberValidationContextFfi) throws 
    
    /**
     * Determine if `signing_identity` is valid for an external sender in
     * the ExternalSendersExtension stored in the group context.
     *
     * A `timestamp` value can optionally be supplied to aid with validation
     * of a [`Credential`](mls-rs-core::identity::Credential) that requires
     * time based context. For example, X.509 certificates can become expired.
     */
    func validateExternalSender(signingIdentity: SigningIdentityFfi, timestamp: UInt64?, extensions: ExtensionListFfi?) throws 
    
    /**
     * A unique identifier for `signing_identity`.
     *
     * The MLS protocol requires that each member of a group has a unique
     * set of identifiers according to the application.
     */
    func identity(signingIdentity: SigningIdentityFfi, extensions: ExtensionListFfi) throws  -> Data
    
    /**
     * Determines if `successor` can remove `predecessor` as part of an external commit.
     *
     * The MLS protocol allows for removal of an existing member when adding a
     * new member via external commit. This function determines if a removal
     * should be allowed by providing the target member to be removed as
     * `predecessor` and the new member as `successor`.
     */
    func validSuccessor(predecessor: SigningIdentityFfi, successor: SigningIdentityFfi, extensions: ExtensionListFfi) throws  -> Bool
    
    /**
     * Credential types that are supported by this provider.
     */
    func supportedTypes()  -> [UInt16]
    
}
/**
 * Identity system that can be used to validate a
 * [`SigningIdentity`](mls-rs-core::identity::SigningIdentity)
 */
open class IdentityProviderProtocolImpl: IdentityProviderProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_mls_rs_uniffi_ios_fn_clone_identityproviderprotocol(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_mls_rs_uniffi_ios_fn_free_identityproviderprotocol(pointer, $0) }
    }

    

    
    /**
     * Determine if `signing_identity` is valid for a group member.
     *
     * A `timestamp` value can optionally be supplied to aid with validation
     * of a [`Credential`](mls-rs-core::identity::Credential) that requires
     * time based context. For example, X.509 certificates can become expired.
     */
open func validateMember(signingIdentity: SigningIdentityFfi, timestamp: UInt64?, context: MemberValidationContextFfi)throws   {try rustCallWithError(FfiConverterTypeMlSrsError_lift) {
    uniffi_mls_rs_uniffi_ios_fn_method_identityproviderprotocol_validate_member(self.uniffiClonePointer(),
        FfiConverterTypeSigningIdentityFFI_lower(signingIdentity),
        FfiConverterOptionUInt64.lower(timestamp),
        FfiConverterTypeMemberValidationContextFFI_lower(context),$0
    )
}
}
    
    /**
     * Determine if `signing_identity` is valid for an external sender in
     * the ExternalSendersExtension stored in the group context.
     *
     * A `timestamp` value can optionally be supplied to aid with validation
     * of a [`Credential`](mls-rs-core::identity::Credential) that requires
     * time based context. For example, X.509 certificates can become expired.
     */
open func validateExternalSender(signingIdentity: SigningIdentityFfi, timestamp: UInt64?, extensions: ExtensionListFfi?)throws   {try rustCallWithError(FfiConverterTypeMlSrsError_lift) {
    uniffi_mls_rs_uniffi_ios_fn_method_identityproviderprotocol_validate_external_sender(self.uniffiClonePointer(),
        FfiConverterTypeSigningIdentityFFI_lower(signingIdentity),
        FfiConverterOptionUInt64.lower(timestamp),
        FfiConverterOptionTypeExtensionListFFI.lower(extensions),$0
    )
}
}
    
    /**
     * A unique identifier for `signing_identity`.
     *
     * The MLS protocol requires that each member of a group has a unique
     * set of identifiers according to the application.
     */
open func identity(signingIdentity: SigningIdentityFfi, extensions: ExtensionListFfi)throws  -> Data  {
    return try  FfiConverterData.lift(try rustCallWithError(FfiConverterTypeMlSrsError_lift) {
    uniffi_mls_rs_uniffi_ios_fn_method_identityproviderprotocol_identity(self.uniffiClonePointer(),
        FfiConverterTypeSigningIdentityFFI_lower(signingIdentity),
        FfiConverterTypeExtensionListFFI_lower(extensions),$0
    )
})
}
    
    /**
     * Determines if `successor` can remove `predecessor` as part of an external commit.
     *
     * The MLS protocol allows for removal of an existing member when adding a
     * new member via external commit. This function determines if a removal
     * should be allowed by providing the target member to be removed as
     * `predecessor` and the new member as `successor`.
     */
open func validSuccessor(predecessor: SigningIdentityFfi, successor: SigningIdentityFfi, extensions: ExtensionListFfi)throws  -> Bool  {
    return try  FfiConverterBool.lift(try rustCallWithError(FfiConverterTypeMlSrsError_lift) {
    uniffi_mls_rs_uniffi_ios_fn_method_identityproviderprotocol_valid_successor(self.uniffiClonePointer(),
        FfiConverterTypeSigningIdentityFFI_lower(predecessor),
        FfiConverterTypeSigningIdentityFFI_lower(successor),
        FfiConverterTypeExtensionListFFI_lower(extensions),$0
    )
})
}
    
    /**
     * Credential types that are supported by this provider.
     */
open func supportedTypes() -> [UInt16]  {
    return try!  FfiConverterSequenceUInt16.lift(try! rustCall() {
    uniffi_mls_rs_uniffi_ios_fn_method_identityproviderprotocol_supported_types(self.uniffiClonePointer(),$0
    )
})
}
    

}


// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceIdentityProviderProtocol {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    //
    // This creates 1-element array, since this seems to be the only way to construct a const
    // pointer that we can pass to the Rust code.
    static let vtable: [UniffiVTableCallbackInterfaceIdentityProviderProtocol] = [UniffiVTableCallbackInterfaceIdentityProviderProtocol(
        validateMember: { (
            uniffiHandle: UInt64,
            signingIdentity: UnsafeMutableRawPointer,
            timestamp: RustBuffer,
            context: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterTypeIdentityProviderProtocol.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try uniffiObj.validateMember(
                     signingIdentity: try FfiConverterTypeSigningIdentityFFI_lift(signingIdentity),
                     timestamp: try FfiConverterOptionUInt64.lift(timestamp),
                     context: try FfiConverterTypeMemberValidationContextFFI_lift(context)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCallWithError(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn,
                lowerError: FfiConverterTypeMlSrsError_lower
            )
        },
        validateExternalSender: { (
            uniffiHandle: UInt64,
            signingIdentity: UnsafeMutableRawPointer,
            timestamp: RustBuffer,
            extensions: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterTypeIdentityProviderProtocol.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try uniffiObj.validateExternalSender(
                     signingIdentity: try FfiConverterTypeSigningIdentityFFI_lift(signingIdentity),
                     timestamp: try FfiConverterOptionUInt64.lift(timestamp),
                     extensions: try FfiConverterOptionTypeExtensionListFFI.lift(extensions)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCallWithError(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn,
                lowerError: FfiConverterTypeMlSrsError_lower
            )
        },
        identity: { (
            uniffiHandle: UInt64,
            signingIdentity: UnsafeMutableRawPointer,
            extensions: UnsafeMutableRawPointer,
            uniffiOutReturn: UnsafeMutablePointer<RustBuffer>,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> Data in
                guard let uniffiObj = try? FfiConverterTypeIdentityProviderProtocol.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try uniffiObj.identity(
                     signingIdentity: try FfiConverterTypeSigningIdentityFFI_lift(signingIdentity),
                     extensions: try FfiConverterTypeExtensionListFFI_lift(extensions)
                )
            }

            
            let writeReturn = { uniffiOutReturn.pointee = FfiConverterData.lower($0) }
            uniffiTraitInterfaceCallWithError(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn,
                lowerError: FfiConverterTypeMlSrsError_lower
            )
        },
        validSuccessor: { (
            uniffiHandle: UInt64,
            predecessor: UnsafeMutableRawPointer,
            successor: UnsafeMutableRawPointer,
            extensions: UnsafeMutableRawPointer,
            uniffiOutReturn: UnsafeMutablePointer<Int8>,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> Bool in
                guard let uniffiObj = try? FfiConverterTypeIdentityProviderProtocol.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try uniffiObj.validSuccessor(
                     predecessor: try FfiConverterTypeSigningIdentityFFI_lift(predecessor),
                     successor: try FfiConverterTypeSigningIdentityFFI_lift(successor),
                     extensions: try FfiConverterTypeExtensionListFFI_lift(extensions)
                )
            }

            
            let writeReturn = { uniffiOutReturn.pointee = FfiConverterBool.lower($0) }
            uniffiTraitInterfaceCallWithError(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn,
                lowerError: FfiConverterTypeMlSrsError_lower
            )
        },
        supportedTypes: { (
            uniffiHandle: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<RustBuffer>,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> [UInt16] in
                guard let uniffiObj = try? FfiConverterTypeIdentityProviderProtocol.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.supportedTypes(
                )
            }

            
            let writeReturn = { uniffiOutReturn.pointee = FfiConverterSequenceUInt16.lower($0) }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            let result = try? FfiConverterTypeIdentityProviderProtocol.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface IdentityProviderProtocol: handle missing in uniffiFree")
            }
        }
    )]
}

private func uniffiCallbackInitIdentityProviderProtocol() {
    uniffi_mls_rs_uniffi_ios_fn_init_callback_vtable_identityproviderprotocol(UniffiCallbackInterfaceIdentityProviderProtocol.vtable)
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeIdentityProviderProtocol: FfiConverter {
    fileprivate static let handleMap = UniffiHandleMap<IdentityProviderProtocol>()

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = IdentityProviderProtocol

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> IdentityProviderProtocol {
        return IdentityProviderProtocolImpl(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: IdentityProviderProtocol) -> UnsafeMutableRawPointer {
        guard let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: handleMap.insert(obj: value))) else {
            fatalError("Cast to UnsafeMutableRawPointer failed")
        }
        return ptr
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> IdentityProviderProtocol {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: IdentityProviderProtocol, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeIdentityProviderProtocol_lift(_ pointer: UnsafeMutableRawPointer) throws -> IdentityProviderProtocol {
    return try FfiConverterTypeIdentityProviderProtocol.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeIdentityProviderProtocol_lower(_ value: IdentityProviderProtocol) -> UnsafeMutableRawPointer {
    return FfiConverterTypeIdentityProviderProtocol.lower(value)
}






public protocol KeyPackageFfiProtocol: AnyObject {
    
}
open class KeyPackageFfi: KeyPackageFfiProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_mls_rs_uniffi_ios_fn_clone_keypackageffi(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_mls_rs_uniffi_ios_fn_free_keypackageffi(pointer, $0) }
    }

    

    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeKeyPackageFFI: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = KeyPackageFfi

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> KeyPackageFfi {
        return KeyPackageFfi(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: KeyPackageFfi) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> KeyPackageFfi {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: KeyPackageFfi, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeKeyPackageFFI_lift(_ pointer: UnsafeMutableRawPointer) throws -> KeyPackageFfi {
    return try FfiConverterTypeKeyPackageFFI.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeKeyPackageFFI_lower(_ value: KeyPackageFfi) -> UnsafeMutableRawPointer {
    return FfiConverterTypeKeyPackageFFI.lower(value)
}






public protocol KeyPackageStorageProtocol: AnyObject {
    
    /**
     * Delete [`KeyPackageData`] referenced by `id`.
     *
     * This function is called automatically when the key package referenced
     * by `id` is used to successfully join a group.
     *
     * # Warning
     *
     * [`KeyPackageData`] internally contains secret key values. The
     * provided delete mechanism should securely erase data.
     */
    func delete(id: Data) throws 
    
    /**
     * Store [`KeyPackageData`] that can be accessed by `id` in the future.
     *
     * This function is automatically called whenever a new key package is created.
     */
    func insert(id: Data, pkg: KeyPackageDataFfi) throws 
    
    /**
     * Retrieve [`KeyPackageData`] by its `id`.
     *
     * `None` should be returned in the event that no key packages are found
     * that match `id`.
     */
    func get(id: Data) throws  -> KeyPackageDataFfi?
    
}
open class KeyPackageStorageProtocolImpl: KeyPackageStorageProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_mls_rs_uniffi_ios_fn_clone_keypackagestorageprotocol(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_mls_rs_uniffi_ios_fn_free_keypackagestorageprotocol(pointer, $0) }
    }

    

    
    /**
     * Delete [`KeyPackageData`] referenced by `id`.
     *
     * This function is called automatically when the key package referenced
     * by `id` is used to successfully join a group.
     *
     * # Warning
     *
     * [`KeyPackageData`] internally contains secret key values. The
     * provided delete mechanism should securely erase data.
     */
open func delete(id: Data)throws   {try rustCallWithError(FfiConverterTypeMlSrsError_lift) {
    uniffi_mls_rs_uniffi_ios_fn_method_keypackagestorageprotocol_delete(self.uniffiClonePointer(),
        FfiConverterData.lower(id),$0
    )
}
}
    
    /**
     * Store [`KeyPackageData`] that can be accessed by `id` in the future.
     *
     * This function is automatically called whenever a new key package is created.
     */
open func insert(id: Data, pkg: KeyPackageDataFfi)throws   {try rustCallWithError(FfiConverterTypeMlSrsError_lift) {
    uniffi_mls_rs_uniffi_ios_fn_method_keypackagestorageprotocol_insert(self.uniffiClonePointer(),
        FfiConverterData.lower(id),
        FfiConverterTypeKeyPackageDataFFI_lower(pkg),$0
    )
}
}
    
    /**
     * Retrieve [`KeyPackageData`] by its `id`.
     *
     * `None` should be returned in the event that no key packages are found
     * that match `id`.
     */
open func get(id: Data)throws  -> KeyPackageDataFfi?  {
    return try  FfiConverterOptionTypeKeyPackageDataFFI.lift(try rustCallWithError(FfiConverterTypeMlSrsError_lift) {
    uniffi_mls_rs_uniffi_ios_fn_method_keypackagestorageprotocol_get(self.uniffiClonePointer(),
        FfiConverterData.lower(id),$0
    )
})
}
    

}


// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceKeyPackageStorageProtocol {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    //
    // This creates 1-element array, since this seems to be the only way to construct a const
    // pointer that we can pass to the Rust code.
    static let vtable: [UniffiVTableCallbackInterfaceKeyPackageStorageProtocol] = [UniffiVTableCallbackInterfaceKeyPackageStorageProtocol(
        delete: { (
            uniffiHandle: UInt64,
            id: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterTypeKeyPackageStorageProtocol.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try uniffiObj.delete(
                     id: try FfiConverterData.lift(id)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCallWithError(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn,
                lowerError: FfiConverterTypeMlSrsError_lower
            )
        },
        insert: { (
            uniffiHandle: UInt64,
            id: RustBuffer,
            pkg: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterTypeKeyPackageStorageProtocol.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try uniffiObj.insert(
                     id: try FfiConverterData.lift(id),
                     pkg: try FfiConverterTypeKeyPackageDataFFI_lift(pkg)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCallWithError(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn,
                lowerError: FfiConverterTypeMlSrsError_lower
            )
        },
        get: { (
            uniffiHandle: UInt64,
            id: RustBuffer,
            uniffiOutReturn: UnsafeMutablePointer<RustBuffer>,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> KeyPackageDataFfi? in
                guard let uniffiObj = try? FfiConverterTypeKeyPackageStorageProtocol.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try uniffiObj.get(
                     id: try FfiConverterData.lift(id)
                )
            }

            
            let writeReturn = { uniffiOutReturn.pointee = FfiConverterOptionTypeKeyPackageDataFFI.lower($0) }
            uniffiTraitInterfaceCallWithError(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn,
                lowerError: FfiConverterTypeMlSrsError_lower
            )
        },
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            let result = try? FfiConverterTypeKeyPackageStorageProtocol.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface KeyPackageStorageProtocol: handle missing in uniffiFree")
            }
        }
    )]
}

private func uniffiCallbackInitKeyPackageStorageProtocol() {
    uniffi_mls_rs_uniffi_ios_fn_init_callback_vtable_keypackagestorageprotocol(UniffiCallbackInterfaceKeyPackageStorageProtocol.vtable)
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeKeyPackageStorageProtocol: FfiConverter {
    fileprivate static let handleMap = UniffiHandleMap<KeyPackageStorageProtocol>()

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = KeyPackageStorageProtocol

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> KeyPackageStorageProtocol {
        return KeyPackageStorageProtocolImpl(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: KeyPackageStorageProtocol) -> UnsafeMutableRawPointer {
        guard let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: handleMap.insert(obj: value))) else {
            fatalError("Cast to UnsafeMutableRawPointer failed")
        }
        return ptr
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> KeyPackageStorageProtocol {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: KeyPackageStorageProtocol, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeKeyPackageStorageProtocol_lift(_ pointer: UnsafeMutableRawPointer) throws -> KeyPackageStorageProtocol {
    return try FfiConverterTypeKeyPackageStorageProtocol.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeKeyPackageStorageProtocol_lower(_ value: KeyPackageStorageProtocol) -> UnsafeMutableRawPointer {
    return FfiConverterTypeKeyPackageStorageProtocol.lower(value)
}






public protocol LeafNodeFfiProtocol: AnyObject {
    
}
open class LeafNodeFfi: LeafNodeFfiProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_mls_rs_uniffi_ios_fn_clone_leafnodeffi(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_mls_rs_uniffi_ios_fn_free_leafnodeffi(pointer, $0) }
    }

    

    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeLeafNodeFFI: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = LeafNodeFfi

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> LeafNodeFfi {
        return LeafNodeFfi(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: LeafNodeFfi) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LeafNodeFfi {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: LeafNodeFfi, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLeafNodeFFI_lift(_ pointer: UnsafeMutableRawPointer) throws -> LeafNodeFfi {
    return try FfiConverterTypeLeafNodeFFI.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLeafNodeFFI_lower(_ value: LeafNodeFfi) -> UnsafeMutableRawPointer {
    return FfiConverterTypeLeafNodeFFI.lower(value)
}






public protocol MlsMemberFfiProtocol: AnyObject {
    
    func getIndex()  -> UInt32
    
    func getSigningIdentity()  -> SigningIdentityFfi
    
}
open class MlsMemberFfi: MlsMemberFfiProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_mls_rs_uniffi_ios_fn_clone_mlsmemberffi(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_mls_rs_uniffi_ios_fn_free_mlsmemberffi(pointer, $0) }
    }

    

    
open func getIndex() -> UInt32  {
    return try!  FfiConverterUInt32.lift(try! rustCall() {
    uniffi_mls_rs_uniffi_ios_fn_method_mlsmemberffi_get_index(self.uniffiClonePointer(),$0
    )
})
}
    
open func getSigningIdentity() -> SigningIdentityFfi  {
    return try!  FfiConverterTypeSigningIdentityFFI_lift(try! rustCall() {
    uniffi_mls_rs_uniffi_ios_fn_method_mlsmemberffi_get_signing_identity(self.uniffiClonePointer(),$0
    )
})
}
    
    public static func == (self: MlsMemberFfi, other: MlsMemberFfi) -> Bool {
        return try!  FfiConverterBool.lift(
            try! rustCall() {
    uniffi_mls_rs_uniffi_ios_fn_method_mlsmemberffi_uniffi_trait_eq_eq(self.uniffiClonePointer(),
        FfiConverterTypeMLSMemberFFI_lower(other),$0
    )
}
        )
    }

}
extension MlsMemberFfi: Equatable {}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeMLSMemberFFI: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = MlsMemberFfi

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> MlsMemberFfi {
        return MlsMemberFfi(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: MlsMemberFfi) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MlsMemberFfi {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: MlsMemberFfi, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMLSMemberFFI_lift(_ pointer: UnsafeMutableRawPointer) throws -> MlsMemberFfi {
    return try FfiConverterTypeMLSMemberFFI.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMLSMemberFFI_lower(_ value: MlsMemberFfi) -> UnsafeMutableRawPointer {
    return FfiConverterTypeMLSMemberFFI.lower(value)
}






/**
 * Matches types in mls_rs::group::message_processor
 */
public protocol MessageFfiProtocol: AnyObject {
    
    func epoch()  -> UInt64?
    
    func groupId()  -> Data?
    
    func privateMessageContentType()  -> UInt8?
    
    func toBytes() throws  -> Data
    
    func uncheckedAuthData(expectedOuterType: UInt8, expectedInnerType: UInt8?) throws  -> MessageFfi?
    
    func wireFormat()  -> UInt16
    
}
/**
 * Matches types in mls_rs::group::message_processor
 */
open class MessageFfi: MessageFfiProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_mls_rs_uniffi_ios_fn_clone_messageffi(self.pointer, $0) }
    }
public convenience init(bytes: Data)throws  {
    let pointer =
        try rustCallWithError(FfiConverterTypeMlSrsError_lift) {
    uniffi_mls_rs_uniffi_ios_fn_constructor_messageffi_new(
        FfiConverterData.lower(bytes),$0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_mls_rs_uniffi_ios_fn_free_messageffi(pointer, $0) }
    }

    

    
open func epoch() -> UInt64?  {
    return try!  FfiConverterOptionUInt64.lift(try! rustCall() {
    uniffi_mls_rs_uniffi_ios_fn_method_messageffi_epoch(self.uniffiClonePointer(),$0
    )
})
}
    
open func groupId() -> Data?  {
    return try!  FfiConverterOptionData.lift(try! rustCall() {
    uniffi_mls_rs_uniffi_ios_fn_method_messageffi_group_id(self.uniffiClonePointer(),$0
    )
})
}
    
open func privateMessageContentType() -> UInt8?  {
    return try!  FfiConverterOptionUInt8.lift(try! rustCall() {
    uniffi_mls_rs_uniffi_ios_fn_method_messageffi_private_message_content_type(self.uniffiClonePointer(),$0
    )
})
}
    
open func toBytes()throws  -> Data  {
    return try  FfiConverterData.lift(try rustCallWithError(FfiConverterTypeMlSrsError_lift) {
    uniffi_mls_rs_uniffi_ios_fn_method_messageffi_to_bytes(self.uniffiClonePointer(),$0
    )
})
}
    
open func uncheckedAuthData(expectedOuterType: UInt8, expectedInnerType: UInt8?)throws  -> MessageFfi?  {
    return try  FfiConverterOptionTypeMessageFFI.lift(try rustCallWithError(FfiConverterTypeMlSrsError_lift) {
    uniffi_mls_rs_uniffi_ios_fn_method_messageffi_unchecked_auth_data(self.uniffiClonePointer(),
        FfiConverterUInt8.lower(expectedOuterType),
        FfiConverterOptionUInt8.lower(expectedInnerType),$0
    )
})
}
    
open func wireFormat() -> UInt16  {
    return try!  FfiConverterUInt16.lift(try! rustCall() {
    uniffi_mls_rs_uniffi_ios_fn_method_messageffi_wire_format(self.uniffiClonePointer(),$0
    )
})
}
    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeMessageFFI: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = MessageFfi

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> MessageFfi {
        return MessageFfi(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: MessageFfi) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MessageFfi {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: MessageFfi, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMessageFFI_lift(_ pointer: UnsafeMutableRawPointer) throws -> MessageFfi {
    return try FfiConverterTypeMessageFFI.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMessageFFI_lower(_ value: MessageFfi) -> UnsafeMutableRawPointer {
    return FfiConverterTypeMessageFFI.lower(value)
}






public protocol SigningIdentityFfiProtocol: AnyObject {
    
    func basicCredential()  -> Data?
    
    func nodeSigningKey()  -> SignaturePublicKeyFfi
    
}
open class SigningIdentityFfi: SigningIdentityFfiProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_mls_rs_uniffi_ios_fn_clone_signingidentityffi(self.pointer, $0) }
    }
public convenience init(signatureKeyData: Data, basicCredential: Data)throws  {
    let pointer =
        try rustCallWithError(FfiConverterTypeMlSrsError_lift) {
    uniffi_mls_rs_uniffi_ios_fn_constructor_signingidentityffi_new(
        FfiConverterData.lower(signatureKeyData),
        FfiConverterData.lower(basicCredential),$0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_mls_rs_uniffi_ios_fn_free_signingidentityffi(pointer, $0) }
    }

    

    
open func basicCredential() -> Data?  {
    return try!  FfiConverterOptionData.lift(try! rustCall() {
    uniffi_mls_rs_uniffi_ios_fn_method_signingidentityffi_basic_credential(self.uniffiClonePointer(),$0
    )
})
}
    
open func nodeSigningKey() -> SignaturePublicKeyFfi  {
    return try!  FfiConverterTypeSignaturePublicKeyFFI_lift(try! rustCall() {
    uniffi_mls_rs_uniffi_ios_fn_method_signingidentityffi_node_signing_key(self.uniffiClonePointer(),$0
    )
})
}
    
    public static func == (self: SigningIdentityFfi, other: SigningIdentityFfi) -> Bool {
        return try!  FfiConverterBool.lift(
            try! rustCall() {
    uniffi_mls_rs_uniffi_ios_fn_method_signingidentityffi_uniffi_trait_eq_eq(self.uniffiClonePointer(),
        FfiConverterTypeSigningIdentityFFI_lower(other),$0
    )
}
        )
    }

}
extension SigningIdentityFfi: Equatable {}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSigningIdentityFFI: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = SigningIdentityFfi

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> SigningIdentityFfi {
        return SigningIdentityFfi(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: SigningIdentityFfi) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SigningIdentityFfi {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: SigningIdentityFfi, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSigningIdentityFFI_lift(_ pointer: UnsafeMutableRawPointer) throws -> SigningIdentityFfi {
    return try FfiConverterTypeSigningIdentityFFI.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSigningIdentityFFI_lower(_ value: SigningIdentityFfi) -> UnsafeMutableRawPointer {
    return FfiConverterTypeSigningIdentityFFI.lower(value)
}




public struct ClientConfigFfi {
    public var clientKeypackageStorage: KeyPackageStorageProtocol
    public var groupStateStorage: GroupStateStorageProtocol
    public var identityProviderStorage: IdentityProviderProtocol
    /**
     * Use the ratchet tree extension. If this is false, then you
     * must supply `ratchet_tree` out of band to clients.
     */
    public var useRatchetTreeExtension: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(clientKeypackageStorage: KeyPackageStorageProtocol, groupStateStorage: GroupStateStorageProtocol, identityProviderStorage: IdentityProviderProtocol, 
        /**
         * Use the ratchet tree extension. If this is false, then you
         * must supply `ratchet_tree` out of band to clients.
         */useRatchetTreeExtension: Bool) {
        self.clientKeypackageStorage = clientKeypackageStorage
        self.groupStateStorage = groupStateStorage
        self.identityProviderStorage = identityProviderStorage
        self.useRatchetTreeExtension = useRatchetTreeExtension
    }
}

#if compiler(>=6)
extension ClientConfigFfi: Sendable {}
#endif



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeClientConfigFFI: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ClientConfigFfi {
        return
            try ClientConfigFfi(
                clientKeypackageStorage: FfiConverterTypeKeyPackageStorageProtocol.read(from: &buf), 
                groupStateStorage: FfiConverterTypeGroupStateStorageProtocol.read(from: &buf), 
                identityProviderStorage: FfiConverterTypeIdentityProviderProtocol.read(from: &buf), 
                useRatchetTreeExtension: FfiConverterBool.read(from: &buf)
        )
    }

    public static func write(_ value: ClientConfigFfi, into buf: inout [UInt8]) {
        FfiConverterTypeKeyPackageStorageProtocol.write(value.clientKeypackageStorage, into: &buf)
        FfiConverterTypeGroupStateStorageProtocol.write(value.groupStateStorage, into: &buf)
        FfiConverterTypeIdentityProviderProtocol.write(value.identityProviderStorage, into: &buf)
        FfiConverterBool.write(value.useRatchetTreeExtension, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeClientConfigFFI_lift(_ buf: RustBuffer) throws -> ClientConfigFfi {
    return try FfiConverterTypeClientConfigFFI.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeClientConfigFFI_lower(_ value: ClientConfigFfi) -> RustBuffer {
    return FfiConverterTypeClientConfigFFI.lower(value)
}


public struct CommitOutputFfi {
    /**
     * Commit message to send to other group members.
     */
    public var commitMessage: MessageFfi
    /**
     * Welcome message to send to new group members. This will be
     * `None` if the commit did not add new members.
     */
    public var welcomeMessage: MessageFfi?
    /**
     * Ratchet tree that can be sent out of band if the ratchet tree
     * extension is not used.
     * A group info that can be provided to new members in order to
     * enable external commit functionality.
     */
    public var groupInfo: MessageFfi?
    /**
     * Proposals that were received in the prior epoch but not included in the following commit.
     */
    public var unusedProposals: [ProposalFfi]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Commit message to send to other group members.
         */commitMessage: MessageFfi, 
        /**
         * Welcome message to send to new group members. This will be
         * `None` if the commit did not add new members.
         */welcomeMessage: MessageFfi?, 
        /**
         * Ratchet tree that can be sent out of band if the ratchet tree
         * extension is not used.
         * A group info that can be provided to new members in order to
         * enable external commit functionality.
         */groupInfo: MessageFfi?, 
        /**
         * Proposals that were received in the prior epoch but not included in the following commit.
         */unusedProposals: [ProposalFfi]) {
        self.commitMessage = commitMessage
        self.welcomeMessage = welcomeMessage
        self.groupInfo = groupInfo
        self.unusedProposals = unusedProposals
    }
}

#if compiler(>=6)
extension CommitOutputFfi: Sendable {}
#endif



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeCommitOutputFFI: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CommitOutputFfi {
        return
            try CommitOutputFfi(
                commitMessage: FfiConverterTypeMessageFFI.read(from: &buf), 
                welcomeMessage: FfiConverterOptionTypeMessageFFI.read(from: &buf), 
                groupInfo: FfiConverterOptionTypeMessageFFI.read(from: &buf), 
                unusedProposals: FfiConverterSequenceTypeProposalFFI.read(from: &buf)
        )
    }

    public static func write(_ value: CommitOutputFfi, into buf: inout [UInt8]) {
        FfiConverterTypeMessageFFI.write(value.commitMessage, into: &buf)
        FfiConverterOptionTypeMessageFFI.write(value.welcomeMessage, into: &buf)
        FfiConverterOptionTypeMessageFFI.write(value.groupInfo, into: &buf)
        FfiConverterSequenceTypeProposalFFI.write(value.unusedProposals, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCommitOutputFFI_lift(_ buf: RustBuffer) throws -> CommitOutputFfi {
    return try FfiConverterTypeCommitOutputFFI.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCommitOutputFFI_lower(_ value: CommitOutputFfi) -> RustBuffer {
    return FfiConverterTypeCommitOutputFFI.lower(value)
}


public struct EpochRecordFfi {
    /**
     * A unique epoch identifier within a particular group.
     */
    public var id: UInt64
    public var data: Data

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * A unique epoch identifier within a particular group.
         */id: UInt64, data: Data) {
        self.id = id
        self.data = data
    }
}

#if compiler(>=6)
extension EpochRecordFfi: Sendable {}
#endif


extension EpochRecordFfi: Equatable, Hashable {
    public static func ==(lhs: EpochRecordFfi, rhs: EpochRecordFfi) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.data != rhs.data {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(data)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeEpochRecordFFI: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> EpochRecordFfi {
        return
            try EpochRecordFfi(
                id: FfiConverterUInt64.read(from: &buf), 
                data: FfiConverterData.read(from: &buf)
        )
    }

    public static func write(_ value: EpochRecordFfi, into buf: inout [UInt8]) {
        FfiConverterUInt64.write(value.id, into: &buf)
        FfiConverterData.write(value.data, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeEpochRecordFFI_lift(_ buf: RustBuffer) throws -> EpochRecordFfi {
    return try FfiConverterTypeEpochRecordFFI.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeEpochRecordFFI_lower(_ value: EpochRecordFfi) -> RustBuffer {
    return FfiConverterTypeEpochRecordFFI.lower(value)
}


public struct GroupContextFfi {
    public var protocolVersion: UInt16
    public var cipherSuite: CipherSuiteFfi
    public var groupId: Data
    public var epoch: UInt64
    public var treeHash: Data
    public var confirmedTranscriptHash: Data
    public var extensions: ExtensionListFfi

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(protocolVersion: UInt16, cipherSuite: CipherSuiteFfi, groupId: Data, epoch: UInt64, treeHash: Data, confirmedTranscriptHash: Data, extensions: ExtensionListFfi) {
        self.protocolVersion = protocolVersion
        self.cipherSuite = cipherSuite
        self.groupId = groupId
        self.epoch = epoch
        self.treeHash = treeHash
        self.confirmedTranscriptHash = confirmedTranscriptHash
        self.extensions = extensions
    }
}

#if compiler(>=6)
extension GroupContextFfi: Sendable {}
#endif



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeGroupContextFFI: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> GroupContextFfi {
        return
            try GroupContextFfi(
                protocolVersion: FfiConverterUInt16.read(from: &buf), 
                cipherSuite: FfiConverterTypeCipherSuiteFFI.read(from: &buf), 
                groupId: FfiConverterData.read(from: &buf), 
                epoch: FfiConverterUInt64.read(from: &buf), 
                treeHash: FfiConverterData.read(from: &buf), 
                confirmedTranscriptHash: FfiConverterData.read(from: &buf), 
                extensions: FfiConverterTypeExtensionListFFI.read(from: &buf)
        )
    }

    public static func write(_ value: GroupContextFfi, into buf: inout [UInt8]) {
        FfiConverterUInt16.write(value.protocolVersion, into: &buf)
        FfiConverterTypeCipherSuiteFFI.write(value.cipherSuite, into: &buf)
        FfiConverterData.write(value.groupId, into: &buf)
        FfiConverterUInt64.write(value.epoch, into: &buf)
        FfiConverterData.write(value.treeHash, into: &buf)
        FfiConverterData.write(value.confirmedTranscriptHash, into: &buf)
        FfiConverterTypeExtensionListFFI.write(value.extensions, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeGroupContextFFI_lift(_ buf: RustBuffer) throws -> GroupContextFfi {
    return try FfiConverterTypeGroupContextFFI.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeGroupContextFFI_lower(_ value: GroupContextFfi) -> RustBuffer {
    return FfiConverterTypeGroupContextFFI.lower(value)
}


/**
 * A [`mls_rs::Group`] and [`mls_rs::group::NewMemberInfo`] wrapper.
 */
public struct JoinInfo {
    /**
     * The group that was joined.
     */
    public var group: GroupFfi
    /**
     * Group info extensions found within the Welcome message used to join
     * the group.
     */
    public var groupInfoExtensions: ExtensionListFfi

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The group that was joined.
         */group: GroupFfi, 
        /**
         * Group info extensions found within the Welcome message used to join
         * the group.
         */groupInfoExtensions: ExtensionListFfi) {
        self.group = group
        self.groupInfoExtensions = groupInfoExtensions
    }
}

#if compiler(>=6)
extension JoinInfo: Sendable {}
#endif



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeJoinInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> JoinInfo {
        return
            try JoinInfo(
                group: FfiConverterTypeGroupFFI.read(from: &buf), 
                groupInfoExtensions: FfiConverterTypeExtensionListFFI.read(from: &buf)
        )
    }

    public static func write(_ value: JoinInfo, into buf: inout [UInt8]) {
        FfiConverterTypeGroupFFI.write(value.group, into: &buf)
        FfiConverterTypeExtensionListFFI.write(value.groupInfoExtensions, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeJoinInfo_lift(_ buf: RustBuffer) throws -> JoinInfo {
    return try FfiConverterTypeJoinInfo.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeJoinInfo_lower(_ value: JoinInfo) -> RustBuffer {
    return FfiConverterTypeJoinInfo.lower(value)
}


public struct KeyPackageDataFfi {
    public var keyPackageBytes: Data
    public var initKeyData: Data
    public var leafNodeKeyData: Data
    public var expiration: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(keyPackageBytes: Data, initKeyData: Data, leafNodeKeyData: Data, expiration: UInt64) {
        self.keyPackageBytes = keyPackageBytes
        self.initKeyData = initKeyData
        self.leafNodeKeyData = leafNodeKeyData
        self.expiration = expiration
    }
}

#if compiler(>=6)
extension KeyPackageDataFfi: Sendable {}
#endif


extension KeyPackageDataFfi: Equatable, Hashable {
    public static func ==(lhs: KeyPackageDataFfi, rhs: KeyPackageDataFfi) -> Bool {
        if lhs.keyPackageBytes != rhs.keyPackageBytes {
            return false
        }
        if lhs.initKeyData != rhs.initKeyData {
            return false
        }
        if lhs.leafNodeKeyData != rhs.leafNodeKeyData {
            return false
        }
        if lhs.expiration != rhs.expiration {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(keyPackageBytes)
        hasher.combine(initKeyData)
        hasher.combine(leafNodeKeyData)
        hasher.combine(expiration)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeKeyPackageDataFFI: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> KeyPackageDataFfi {
        return
            try KeyPackageDataFfi(
                keyPackageBytes: FfiConverterData.read(from: &buf), 
                initKeyData: FfiConverterData.read(from: &buf), 
                leafNodeKeyData: FfiConverterData.read(from: &buf), 
                expiration: FfiConverterUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: KeyPackageDataFfi, into buf: inout [UInt8]) {
        FfiConverterData.write(value.keyPackageBytes, into: &buf)
        FfiConverterData.write(value.initKeyData, into: &buf)
        FfiConverterData.write(value.leafNodeKeyData, into: &buf)
        FfiConverterUInt64.write(value.expiration, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeKeyPackageDataFFI_lift(_ buf: RustBuffer) throws -> KeyPackageDataFfi {
    return try FfiConverterTypeKeyPackageDataFFI.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeKeyPackageDataFFI_lower(_ value: KeyPackageDataFfi) -> RustBuffer {
    return FfiConverterTypeKeyPackageDataFFI.lower(value)
}


public struct LeafIndexFfi {
    public var index: UInt32

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(index: UInt32) {
        self.index = index
    }
}

#if compiler(>=6)
extension LeafIndexFfi: Sendable {}
#endif


extension LeafIndexFfi: Equatable, Hashable {
    public static func ==(lhs: LeafIndexFfi, rhs: LeafIndexFfi) -> Bool {
        if lhs.index != rhs.index {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(index)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeLeafIndexFFI: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LeafIndexFfi {
        return
            try LeafIndexFfi(
                index: FfiConverterUInt32.read(from: &buf)
        )
    }

    public static func write(_ value: LeafIndexFfi, into buf: inout [UInt8]) {
        FfiConverterUInt32.write(value.index, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLeafIndexFFI_lift(_ buf: RustBuffer) throws -> LeafIndexFfi {
    return try FfiConverterTypeLeafIndexFFI.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLeafIndexFFI_lower(_ value: LeafIndexFfi) -> RustBuffer {
    return FfiConverterTypeLeafIndexFFI.lower(value)
}


public struct Lifetime {
    public var notBefore: UInt64
    public var notAfter: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(notBefore: UInt64, notAfter: UInt64) {
        self.notBefore = notBefore
        self.notAfter = notAfter
    }
}

#if compiler(>=6)
extension Lifetime: Sendable {}
#endif


extension Lifetime: Equatable, Hashable {
    public static func ==(lhs: Lifetime, rhs: Lifetime) -> Bool {
        if lhs.notBefore != rhs.notBefore {
            return false
        }
        if lhs.notAfter != rhs.notAfter {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(notBefore)
        hasher.combine(notAfter)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeLifetime: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Lifetime {
        return
            try Lifetime(
                notBefore: FfiConverterUInt64.read(from: &buf), 
                notAfter: FfiConverterUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: Lifetime, into buf: inout [UInt8]) {
        FfiConverterUInt64.write(value.notBefore, into: &buf)
        FfiConverterUInt64.write(value.notAfter, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLifetime_lift(_ buf: RustBuffer) throws -> Lifetime {
    return try FfiConverterTypeLifetime.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLifetime_lower(_ value: Lifetime) -> RustBuffer {
    return FfiConverterTypeLifetime.lower(value)
}


public struct ProtocolVersionFfi {
    public var version: UInt16

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(version: UInt16) {
        self.version = version
    }
}

#if compiler(>=6)
extension ProtocolVersionFfi: Sendable {}
#endif


extension ProtocolVersionFfi: Equatable, Hashable {
    public static func ==(lhs: ProtocolVersionFfi, rhs: ProtocolVersionFfi) -> Bool {
        if lhs.version != rhs.version {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(version)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeProtocolVersionFFI: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ProtocolVersionFfi {
        return
            try ProtocolVersionFfi(
                version: FfiConverterUInt16.read(from: &buf)
        )
    }

    public static func write(_ value: ProtocolVersionFfi, into buf: inout [UInt8]) {
        FfiConverterUInt16.write(value.version, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeProtocolVersionFFI_lift(_ buf: RustBuffer) throws -> ProtocolVersionFfi {
    return try FfiConverterTypeProtocolVersionFFI.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeProtocolVersionFFI_lower(_ value: ProtocolVersionFfi) -> RustBuffer {
    return FfiConverterTypeProtocolVersionFFI.lower(value)
}


/**
 * A ([`SignaturePublicKey`], [`SignatureSecretKey`]) pair.
 */
public struct SignatureKeypair {
    public var cipherSuite: CipherSuiteFfi
    public var publicKey: SignaturePublicKey
    public var secretKey: SignatureSecretKey

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(cipherSuite: CipherSuiteFfi, publicKey: SignaturePublicKey, secretKey: SignatureSecretKey) {
        self.cipherSuite = cipherSuite
        self.publicKey = publicKey
        self.secretKey = secretKey
    }
}

#if compiler(>=6)
extension SignatureKeypair: Sendable {}
#endif


extension SignatureKeypair: Equatable, Hashable {
    public static func ==(lhs: SignatureKeypair, rhs: SignatureKeypair) -> Bool {
        if lhs.cipherSuite != rhs.cipherSuite {
            return false
        }
        if lhs.publicKey != rhs.publicKey {
            return false
        }
        if lhs.secretKey != rhs.secretKey {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(cipherSuite)
        hasher.combine(publicKey)
        hasher.combine(secretKey)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSignatureKeypair: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SignatureKeypair {
        return
            try SignatureKeypair(
                cipherSuite: FfiConverterTypeCipherSuiteFFI.read(from: &buf), 
                publicKey: FfiConverterTypeSignaturePublicKey.read(from: &buf), 
                secretKey: FfiConverterTypeSignatureSecretKey.read(from: &buf)
        )
    }

    public static func write(_ value: SignatureKeypair, into buf: inout [UInt8]) {
        FfiConverterTypeCipherSuiteFFI.write(value.cipherSuite, into: &buf)
        FfiConverterTypeSignaturePublicKey.write(value.publicKey, into: &buf)
        FfiConverterTypeSignatureSecretKey.write(value.secretKey, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSignatureKeypair_lift(_ buf: RustBuffer) throws -> SignatureKeypair {
    return try FfiConverterTypeSignatureKeypair.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSignatureKeypair_lower(_ value: SignatureKeypair) -> RustBuffer {
    return FfiConverterTypeSignatureKeypair.lower(value)
}


/**
 * A ([`SignaturePublicKey`], [`SignatureSecretKey`]) pair.
 */
public struct SignatureKeypairFfi {
    public var cipherSuite: CipherSuiteFfi
    public var publicKey: SignaturePublicKeyFfi
    public var secretKey: SignatureSecretKeyFfi

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(cipherSuite: CipherSuiteFfi, publicKey: SignaturePublicKeyFfi, secretKey: SignatureSecretKeyFfi) {
        self.cipherSuite = cipherSuite
        self.publicKey = publicKey
        self.secretKey = secretKey
    }
}

#if compiler(>=6)
extension SignatureKeypairFfi: Sendable {}
#endif


extension SignatureKeypairFfi: Equatable, Hashable {
    public static func ==(lhs: SignatureKeypairFfi, rhs: SignatureKeypairFfi) -> Bool {
        if lhs.cipherSuite != rhs.cipherSuite {
            return false
        }
        if lhs.publicKey != rhs.publicKey {
            return false
        }
        if lhs.secretKey != rhs.secretKey {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(cipherSuite)
        hasher.combine(publicKey)
        hasher.combine(secretKey)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSignatureKeypairFFI: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SignatureKeypairFfi {
        return
            try SignatureKeypairFfi(
                cipherSuite: FfiConverterTypeCipherSuiteFFI.read(from: &buf), 
                publicKey: FfiConverterTypeSignaturePublicKeyFFI.read(from: &buf), 
                secretKey: FfiConverterTypeSignatureSecretKeyFFI.read(from: &buf)
        )
    }

    public static func write(_ value: SignatureKeypairFfi, into buf: inout [UInt8]) {
        FfiConverterTypeCipherSuiteFFI.write(value.cipherSuite, into: &buf)
        FfiConverterTypeSignaturePublicKeyFFI.write(value.publicKey, into: &buf)
        FfiConverterTypeSignatureSecretKeyFFI.write(value.secretKey, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSignatureKeypairFFI_lift(_ buf: RustBuffer) throws -> SignatureKeypairFfi {
    return try FfiConverterTypeSignatureKeypairFFI.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSignatureKeypairFFI_lower(_ value: SignatureKeypairFfi) -> RustBuffer {
    return FfiConverterTypeSignatureKeypairFFI.lower(value)
}


/**
 * A [`mls_rs::crypto::SignaturePublicKey`] wrapper.
 */
public struct SignaturePublicKey {
    public var bytes: Data

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(bytes: Data) {
        self.bytes = bytes
    }
}

#if compiler(>=6)
extension SignaturePublicKey: Sendable {}
#endif


extension SignaturePublicKey: Equatable, Hashable {
    public static func ==(lhs: SignaturePublicKey, rhs: SignaturePublicKey) -> Bool {
        if lhs.bytes != rhs.bytes {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(bytes)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSignaturePublicKey: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SignaturePublicKey {
        return
            try SignaturePublicKey(
                bytes: FfiConverterData.read(from: &buf)
        )
    }

    public static func write(_ value: SignaturePublicKey, into buf: inout [UInt8]) {
        FfiConverterData.write(value.bytes, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSignaturePublicKey_lift(_ buf: RustBuffer) throws -> SignaturePublicKey {
    return try FfiConverterTypeSignaturePublicKey.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSignaturePublicKey_lower(_ value: SignaturePublicKey) -> RustBuffer {
    return FfiConverterTypeSignaturePublicKey.lower(value)
}


/**
 * A [`mls_rs::crypto::SignaturePublicKey`] wrapper.
 */
public struct SignaturePublicKeyFfi {
    public var bytes: Data

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(bytes: Data) {
        self.bytes = bytes
    }
}

#if compiler(>=6)
extension SignaturePublicKeyFfi: Sendable {}
#endif


extension SignaturePublicKeyFfi: Equatable, Hashable {
    public static func ==(lhs: SignaturePublicKeyFfi, rhs: SignaturePublicKeyFfi) -> Bool {
        if lhs.bytes != rhs.bytes {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(bytes)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSignaturePublicKeyFFI: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SignaturePublicKeyFfi {
        return
            try SignaturePublicKeyFfi(
                bytes: FfiConverterData.read(from: &buf)
        )
    }

    public static func write(_ value: SignaturePublicKeyFfi, into buf: inout [UInt8]) {
        FfiConverterData.write(value.bytes, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSignaturePublicKeyFFI_lift(_ buf: RustBuffer) throws -> SignaturePublicKeyFfi {
    return try FfiConverterTypeSignaturePublicKeyFFI.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSignaturePublicKeyFFI_lower(_ value: SignaturePublicKeyFfi) -> RustBuffer {
    return FfiConverterTypeSignaturePublicKeyFFI.lower(value)
}


/**
 * A [`mls_rs::crypto::SignatureSecretKey`] wrapper.
 */
public struct SignatureSecretKey {
    public var bytes: Data

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(bytes: Data) {
        self.bytes = bytes
    }
}

#if compiler(>=6)
extension SignatureSecretKey: Sendable {}
#endif


extension SignatureSecretKey: Equatable, Hashable {
    public static func ==(lhs: SignatureSecretKey, rhs: SignatureSecretKey) -> Bool {
        if lhs.bytes != rhs.bytes {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(bytes)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSignatureSecretKey: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SignatureSecretKey {
        return
            try SignatureSecretKey(
                bytes: FfiConverterData.read(from: &buf)
        )
    }

    public static func write(_ value: SignatureSecretKey, into buf: inout [UInt8]) {
        FfiConverterData.write(value.bytes, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSignatureSecretKey_lift(_ buf: RustBuffer) throws -> SignatureSecretKey {
    return try FfiConverterTypeSignatureSecretKey.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSignatureSecretKey_lower(_ value: SignatureSecretKey) -> RustBuffer {
    return FfiConverterTypeSignatureSecretKey.lower(value)
}


/**
 * A [`mls_rs::crypto::SignatureSecretKey`] wrapper.
 */
public struct SignatureSecretKeyFfi {
    public var bytes: Data

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(bytes: Data) {
        self.bytes = bytes
    }
}

#if compiler(>=6)
extension SignatureSecretKeyFfi: Sendable {}
#endif


extension SignatureSecretKeyFfi: Equatable, Hashable {
    public static func ==(lhs: SignatureSecretKeyFfi, rhs: SignatureSecretKeyFfi) -> Bool {
        if lhs.bytes != rhs.bytes {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(bytes)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSignatureSecretKeyFFI: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SignatureSecretKeyFfi {
        return
            try SignatureSecretKeyFfi(
                bytes: FfiConverterData.read(from: &buf)
        )
    }

    public static func write(_ value: SignatureSecretKeyFfi, into buf: inout [UInt8]) {
        FfiConverterData.write(value.bytes, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSignatureSecretKeyFFI_lift(_ buf: RustBuffer) throws -> SignatureSecretKeyFfi {
    return try FfiConverterTypeSignatureSecretKeyFFI.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSignatureSecretKeyFFI_lower(_ value: SignatureSecretKeyFfi) -> RustBuffer {
    return FfiConverterTypeSignatureSecretKeyFFI.lower(value)
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Supported cipher suites.
 *
 * This is a subset of the cipher suites found in
 * [`mls_rs::CipherSuite`].
 */

public enum CipherSuiteFfi {
    
    case curve25519ChaCha
}


#if compiler(>=6)
extension CipherSuiteFfi: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeCipherSuiteFFI: FfiConverterRustBuffer {
    typealias SwiftType = CipherSuiteFfi

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CipherSuiteFfi {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .curve25519ChaCha
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: CipherSuiteFfi, into buf: inout [UInt8]) {
        switch value {
        
        
        case .curve25519ChaCha:
            writeInt(&buf, Int32(1))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCipherSuiteFFI_lift(_ buf: RustBuffer) throws -> CipherSuiteFfi {
    return try FfiConverterTypeCipherSuiteFFI.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCipherSuiteFFI_lower(_ value: CipherSuiteFfi) -> RustBuffer {
    return FfiConverterTypeCipherSuiteFFI.lower(value)
}


extension CipherSuiteFfi: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum CommitEffectFfi {
    
    case newEpoch(appliedProposals: [ProposalFfi], unusedProposals: [ProposalFfi]
    )
    case reInit
    case removed
}


#if compiler(>=6)
extension CommitEffectFfi: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeCommitEffectFFI: FfiConverterRustBuffer {
    typealias SwiftType = CommitEffectFfi

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CommitEffectFfi {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .newEpoch(appliedProposals: try FfiConverterSequenceTypeProposalFFI.read(from: &buf), unusedProposals: try FfiConverterSequenceTypeProposalFFI.read(from: &buf)
        )
        
        case 2: return .reInit
        
        case 3: return .removed
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: CommitEffectFfi, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .newEpoch(appliedProposals,unusedProposals):
            writeInt(&buf, Int32(1))
            FfiConverterSequenceTypeProposalFFI.write(appliedProposals, into: &buf)
            FfiConverterSequenceTypeProposalFFI.write(unusedProposals, into: &buf)
            
        
        case .reInit:
            writeInt(&buf, Int32(2))
        
        
        case .removed:
            writeInt(&buf, Int32(3))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCommitEffectFFI_lift(_ buf: RustBuffer) throws -> CommitEffectFfi {
    return try FfiConverterTypeCommitEffectFFI.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCommitEffectFFI_lower(_ value: CommitEffectFfi) -> RustBuffer {
    return FfiConverterTypeCommitEffectFFI.lower(value)
}




// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum LeafNodeSource {
    
    case keyPackage(Lifetime
    )
    case update
    case commit(Data
    )
}


#if compiler(>=6)
extension LeafNodeSource: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeLeafNodeSource: FfiConverterRustBuffer {
    typealias SwiftType = LeafNodeSource

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LeafNodeSource {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .keyPackage(try FfiConverterTypeLifetime.read(from: &buf)
        )
        
        case 2: return .update
        
        case 3: return .commit(try FfiConverterData.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: LeafNodeSource, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .keyPackage(v1):
            writeInt(&buf, Int32(1))
            FfiConverterTypeLifetime.write(v1, into: &buf)
            
        
        case .update:
            writeInt(&buf, Int32(2))
        
        
        case let .commit(v1):
            writeInt(&buf, Int32(3))
            FfiConverterData.write(v1, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLeafNodeSource_lift(_ buf: RustBuffer) throws -> LeafNodeSource {
    return try FfiConverterTypeLeafNodeSource.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLeafNodeSource_lower(_ value: LeafNodeSource) -> RustBuffer {
    return FfiConverterTypeLeafNodeSource.lower(value)
}


extension LeafNodeSource: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum MemberValidationContextFfi {
    
    case forCommit(currentContext: GroupContextFfi, newExtensions: ExtensionListFfi
    )
    case forNewGroup(currentContext: GroupContextFfi
    )
    case none
}


#if compiler(>=6)
extension MemberValidationContextFfi: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeMemberValidationContextFFI: FfiConverterRustBuffer {
    typealias SwiftType = MemberValidationContextFfi

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MemberValidationContextFfi {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .forCommit(currentContext: try FfiConverterTypeGroupContextFFI.read(from: &buf), newExtensions: try FfiConverterTypeExtensionListFFI.read(from: &buf)
        )
        
        case 2: return .forNewGroup(currentContext: try FfiConverterTypeGroupContextFFI.read(from: &buf)
        )
        
        case 3: return .none
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: MemberValidationContextFfi, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .forCommit(currentContext,newExtensions):
            writeInt(&buf, Int32(1))
            FfiConverterTypeGroupContextFFI.write(currentContext, into: &buf)
            FfiConverterTypeExtensionListFFI.write(newExtensions, into: &buf)
            
        
        case let .forNewGroup(currentContext):
            writeInt(&buf, Int32(2))
            FfiConverterTypeGroupContextFFI.write(currentContext, into: &buf)
            
        
        case .none:
            writeInt(&buf, Int32(3))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMemberValidationContextFFI_lift(_ buf: RustBuffer) throws -> MemberValidationContextFfi {
    return try FfiConverterTypeMemberValidationContextFFI.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMemberValidationContextFFI_lower(_ value: MemberValidationContextFfi) -> RustBuffer {
    return FfiConverterTypeMemberValidationContextFFI.lower(value)
}





public enum MlSrsError {

    
    
    case MlsError(message: String)
    
    case AnyError(message: String)
    
    case MlsCodecError(message: String)
    
    case UnexpectedCallbackError(message: String)
    
    case UnexpecteMessageFormat(message: String)
    
    case InconsistentOptionalParameters(message: String)
    
    case MissingBasicCredential(message: String)
    
    case UnexpectedMessageTypeDetailed(message: String)
    
    case UnexpectedProposalSender(message: String)
    
    case NotImplemented(message: String)
    
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeMlSrsError: FfiConverterRustBuffer {
    typealias SwiftType = MlSrsError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MlSrsError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .MlsError(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .AnyError(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 3: return .MlsCodecError(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 4: return .UnexpectedCallbackError(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 5: return .UnexpecteMessageFormat(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 6: return .InconsistentOptionalParameters(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 7: return .MissingBasicCredential(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 8: return .UnexpectedMessageTypeDetailed(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 9: return .UnexpectedProposalSender(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 10: return .NotImplemented(
            message: try FfiConverterString.read(from: &buf)
        )
        

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: MlSrsError, into buf: inout [UInt8]) {
        switch value {

        

        
        case .MlsError(_ /* message is ignored*/):
            writeInt(&buf, Int32(1))
        case .AnyError(_ /* message is ignored*/):
            writeInt(&buf, Int32(2))
        case .MlsCodecError(_ /* message is ignored*/):
            writeInt(&buf, Int32(3))
        case .UnexpectedCallbackError(_ /* message is ignored*/):
            writeInt(&buf, Int32(4))
        case .UnexpecteMessageFormat(_ /* message is ignored*/):
            writeInt(&buf, Int32(5))
        case .InconsistentOptionalParameters(_ /* message is ignored*/):
            writeInt(&buf, Int32(6))
        case .MissingBasicCredential(_ /* message is ignored*/):
            writeInt(&buf, Int32(7))
        case .UnexpectedMessageTypeDetailed(_ /* message is ignored*/):
            writeInt(&buf, Int32(8))
        case .UnexpectedProposalSender(_ /* message is ignored*/):
            writeInt(&buf, Int32(9))
        case .NotImplemented(_ /* message is ignored*/):
            writeInt(&buf, Int32(10))

        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMlSrsError_lift(_ buf: RustBuffer) throws -> MlSrsError {
    return try FfiConverterTypeMlSrsError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMlSrsError_lower(_ value: MlSrsError) -> RustBuffer {
    return FfiConverterTypeMlSrsError.lower(value)
}


extension MlSrsError: Equatable, Hashable {}



extension MlSrsError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum ProposalFfi {
    
    case add(KeyPackageFfi
    )
    case update(new: SigningIdentityFfi, senderIndex: UInt32
    )
    case remove(UInt32
    )
}


#if compiler(>=6)
extension ProposalFfi: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeProposalFFI: FfiConverterRustBuffer {
    typealias SwiftType = ProposalFfi

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ProposalFfi {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .add(try FfiConverterTypeKeyPackageFFI.read(from: &buf)
        )
        
        case 2: return .update(new: try FfiConverterTypeSigningIdentityFFI.read(from: &buf), senderIndex: try FfiConverterUInt32.read(from: &buf)
        )
        
        case 3: return .remove(try FfiConverterUInt32.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ProposalFfi, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .add(v1):
            writeInt(&buf, Int32(1))
            FfiConverterTypeKeyPackageFFI.write(v1, into: &buf)
            
        
        case let .update(new,senderIndex):
            writeInt(&buf, Int32(2))
            FfiConverterTypeSigningIdentityFFI.write(new, into: &buf)
            FfiConverterUInt32.write(senderIndex, into: &buf)
            
        
        case let .remove(v1):
            writeInt(&buf, Int32(3))
            FfiConverterUInt32.write(v1, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeProposalFFI_lift(_ buf: RustBuffer) throws -> ProposalFfi {
    return try FfiConverterTypeProposalFFI.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeProposalFFI_lower(_ value: ProposalFfi) -> RustBuffer {
    return FfiConverterTypeProposalFFI.lower(value)
}




// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum ProtocolVersion {
    
    /**
     * MLS version 1.0.
     */
    case mls10
}


#if compiler(>=6)
extension ProtocolVersion: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeProtocolVersion: FfiConverterRustBuffer {
    typealias SwiftType = ProtocolVersion

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ProtocolVersion {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .mls10
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ProtocolVersion, into buf: inout [UInt8]) {
        switch value {
        
        
        case .mls10:
            writeInt(&buf, Int32(1))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeProtocolVersion_lift(_ buf: RustBuffer) throws -> ProtocolVersion {
    return try FfiConverterTypeProtocolVersion.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeProtocolVersion_lower(_ value: ProtocolVersion) -> RustBuffer {
    return FfiConverterTypeProtocolVersion.lower(value)
}


extension ProtocolVersion: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * A [`mls_rs::group::ReceivedMessage`] wrapper.
 */

public enum ReceivedMessageFfi {
    
    /**
     * A decrypted application message.
     *
     * The encoding of the data in the message is
     * application-specific and is not determined by MLS.
     */
    case applicationMessage(sender: SigningIdentityFfi, data: Data, authenticatedData: Data
    )
    /**
     * A new commit was processed creating a new group state.
     */
    case commit(committer: SigningIdentityFfi, effect: CommitEffectFfi
    )
    /**
     * A proposal was received.
     */
    case receivedProposal(sender: SigningIdentityFfi, proposal: ProposalFfi
    )
    /**
     * Validated GroupInfo object.
     */
    case groupInfo
    /**
     * Validated welcome message.
     */
    case welcome
    /**
     * Validated key package.
     */
    case keyPackage
}


#if compiler(>=6)
extension ReceivedMessageFfi: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeReceivedMessageFFI: FfiConverterRustBuffer {
    typealias SwiftType = ReceivedMessageFfi

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ReceivedMessageFfi {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .applicationMessage(sender: try FfiConverterTypeSigningIdentityFFI.read(from: &buf), data: try FfiConverterData.read(from: &buf), authenticatedData: try FfiConverterData.read(from: &buf)
        )
        
        case 2: return .commit(committer: try FfiConverterTypeSigningIdentityFFI.read(from: &buf), effect: try FfiConverterTypeCommitEffectFFI.read(from: &buf)
        )
        
        case 3: return .receivedProposal(sender: try FfiConverterTypeSigningIdentityFFI.read(from: &buf), proposal: try FfiConverterTypeProposalFFI.read(from: &buf)
        )
        
        case 4: return .groupInfo
        
        case 5: return .welcome
        
        case 6: return .keyPackage
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ReceivedMessageFfi, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .applicationMessage(sender,data,authenticatedData):
            writeInt(&buf, Int32(1))
            FfiConverterTypeSigningIdentityFFI.write(sender, into: &buf)
            FfiConverterData.write(data, into: &buf)
            FfiConverterData.write(authenticatedData, into: &buf)
            
        
        case let .commit(committer,effect):
            writeInt(&buf, Int32(2))
            FfiConverterTypeSigningIdentityFFI.write(committer, into: &buf)
            FfiConverterTypeCommitEffectFFI.write(effect, into: &buf)
            
        
        case let .receivedProposal(sender,proposal):
            writeInt(&buf, Int32(3))
            FfiConverterTypeSigningIdentityFFI.write(sender, into: &buf)
            FfiConverterTypeProposalFFI.write(proposal, into: &buf)
            
        
        case .groupInfo:
            writeInt(&buf, Int32(4))
        
        
        case .welcome:
            writeInt(&buf, Int32(5))
        
        
        case .keyPackage:
            writeInt(&buf, Int32(6))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeReceivedMessageFFI_lift(_ buf: RustBuffer) throws -> ReceivedMessageFfi {
    return try FfiConverterTypeReceivedMessageFFI.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeReceivedMessageFFI_lower(_ value: ReceivedMessageFfi) -> RustBuffer {
    return FfiConverterTypeReceivedMessageFFI.lower(value)
}




#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionUInt8: FfiConverterRustBuffer {
    typealias SwiftType = UInt8?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterUInt8.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterUInt8.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionUInt64: FfiConverterRustBuffer {
    typealias SwiftType = UInt64?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterUInt64.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterUInt64.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionData: FfiConverterRustBuffer {
    typealias SwiftType = Data?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterData.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterData.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeExtensionListFFI: FfiConverterRustBuffer {
    typealias SwiftType = ExtensionListFfi?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeExtensionListFFI.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeExtensionListFFI.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeMLSMemberFFI: FfiConverterRustBuffer {
    typealias SwiftType = MlsMemberFfi?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeMLSMemberFFI.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeMLSMemberFFI.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeMessageFFI: FfiConverterRustBuffer {
    typealias SwiftType = MessageFfi?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeMessageFFI.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeMessageFFI.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeSigningIdentityFFI: FfiConverterRustBuffer {
    typealias SwiftType = SigningIdentityFfi?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeSigningIdentityFFI.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeSigningIdentityFFI.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeKeyPackageDataFFI: FfiConverterRustBuffer {
    typealias SwiftType = KeyPackageDataFfi?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeKeyPackageDataFFI.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeKeyPackageDataFFI.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeSignatureSecretKeyFFI: FfiConverterRustBuffer {
    typealias SwiftType = SignatureSecretKeyFfi?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeSignatureSecretKeyFFI.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeSignatureSecretKeyFFI.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceUInt16: FfiConverterRustBuffer {
    typealias SwiftType = [UInt16]

    public static func write(_ value: [UInt16], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterUInt16.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [UInt16] {
        let len: Int32 = try readInt(&buf)
        var seq = [UInt16]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterUInt16.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeMLSMemberFFI: FfiConverterRustBuffer {
    typealias SwiftType = [MlsMemberFfi]

    public static func write(_ value: [MlsMemberFfi], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeMLSMemberFFI.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [MlsMemberFfi] {
        let len: Int32 = try readInt(&buf)
        var seq = [MlsMemberFfi]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeMLSMemberFFI.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeMessageFFI: FfiConverterRustBuffer {
    typealias SwiftType = [MessageFfi]

    public static func write(_ value: [MessageFfi], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeMessageFFI.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [MessageFfi] {
        let len: Int32 = try readInt(&buf)
        var seq = [MessageFfi]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeMessageFFI.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeEpochRecordFFI: FfiConverterRustBuffer {
    typealias SwiftType = [EpochRecordFfi]

    public static func write(_ value: [EpochRecordFfi], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeEpochRecordFFI.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [EpochRecordFfi] {
        let len: Int32 = try readInt(&buf)
        var seq = [EpochRecordFfi]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeEpochRecordFFI.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeProposalFFI: FfiConverterRustBuffer {
    typealias SwiftType = [ProposalFfi]

    public static func write(_ value: [ProposalFfi], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeProposalFFI.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ProposalFfi] {
        let len: Int32 = try readInt(&buf)
        var seq = [ProposalFfi]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeProposalFFI.read(from: &buf))
        }
        return seq
    }
}
/**
 * Create a client config with an in-memory group state storage.
 */
public func clientConfigDefault() -> ClientConfigFfi  {
    return try!  FfiConverterTypeClientConfigFFI_lift(try! rustCall() {
    uniffi_mls_rs_uniffi_ios_fn_func_client_config_default($0
    )
})
}
/**
 * Generate a MLS signature keypair.
 *
 * This will use the default mls-lite crypto provider.
 *
 * See [`mls_rs::CipherSuiteProvider::signature_key_generate`]
 * for details.
 */
public func generateSignatureKeypair(cipherSuite: CipherSuiteFfi)throws  -> SignatureKeypair  {
    return try  FfiConverterTypeSignatureKeypair_lift(try rustCallWithError(FfiConverterTypeMlSrsError_lift) {
    uniffi_mls_rs_uniffi_ios_fn_func_generate_signature_keypair(
        FfiConverterTypeCipherSuiteFFI_lower(cipherSuite),$0
    )
})
}

private enum InitializationResult {
    case ok
    case contractVersionMismatch
    case apiChecksumMismatch
}
// Use a global variable to perform the versioning checks. Swift ensures that
// the code inside is only computed once.
private let initializationResult: InitializationResult = {
    // Get the bindings contract version from our ComponentInterface
    let bindings_contract_version = 29
    // Get the scaffolding contract version by calling the into the dylib
    let scaffolding_contract_version = ffi_mls_rs_uniffi_ios_uniffi_contract_version()
    if bindings_contract_version != scaffolding_contract_version {
        return InitializationResult.contractVersionMismatch
    }
    if (uniffi_mls_rs_uniffi_ios_checksum_func_client_config_default() != 16721) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mls_rs_uniffi_ios_checksum_func_generate_signature_keypair() != 22124) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mls_rs_uniffi_ios_checksum_method_clientffi_create_group() != 29316) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mls_rs_uniffi_ios_checksum_method_clientffi_generate_key_package_message() != 65340) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mls_rs_uniffi_ios_checksum_method_clientffi_join_group() != 49248) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mls_rs_uniffi_ios_checksum_method_clientffi_load_group() != 29821) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mls_rs_uniffi_ios_checksum_method_clientffi_signing_identity() != 5869) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mls_rs_uniffi_ios_checksum_method_groupffi_add_members() != 59554) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mls_rs_uniffi_ios_checksum_method_groupffi_commit() != 31502) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mls_rs_uniffi_ios_checksum_method_groupffi_current_epoch() != 32833) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mls_rs_uniffi_ios_checksum_method_groupffi_current_member_index() != 36178) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mls_rs_uniffi_ios_checksum_method_groupffi_encrypt_application_message() != 27766) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mls_rs_uniffi_ios_checksum_method_groupffi_export_secret() != 34480) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mls_rs_uniffi_ios_checksum_method_groupffi_group_id() != 36382) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mls_rs_uniffi_ios_checksum_method_groupffi_member_at_index() != 9925) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mls_rs_uniffi_ios_checksum_method_groupffi_members() != 4678) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mls_rs_uniffi_ios_checksum_method_groupffi_process_incoming_message() != 59118) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mls_rs_uniffi_ios_checksum_method_groupffi_propose_update() != 5017) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mls_rs_uniffi_ios_checksum_method_groupffi_write_to_storage() != 28067) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mls_rs_uniffi_ios_checksum_method_groupstatestorageprotocol_state() != 8506) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mls_rs_uniffi_ios_checksum_method_groupstatestorageprotocol_epoch() != 15863) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mls_rs_uniffi_ios_checksum_method_groupstatestorageprotocol_write() != 9953) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mls_rs_uniffi_ios_checksum_method_groupstatestorageprotocol_max_epoch_id() != 41922) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mls_rs_uniffi_ios_checksum_method_identityproviderprotocol_validate_member() != 628) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mls_rs_uniffi_ios_checksum_method_identityproviderprotocol_validate_external_sender() != 20738) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mls_rs_uniffi_ios_checksum_method_identityproviderprotocol_identity() != 22084) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mls_rs_uniffi_ios_checksum_method_identityproviderprotocol_valid_successor() != 55983) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mls_rs_uniffi_ios_checksum_method_identityproviderprotocol_supported_types() != 13654) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mls_rs_uniffi_ios_checksum_method_keypackagestorageprotocol_delete() != 35854) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mls_rs_uniffi_ios_checksum_method_keypackagestorageprotocol_insert() != 15077) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mls_rs_uniffi_ios_checksum_method_keypackagestorageprotocol_get() != 60492) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mls_rs_uniffi_ios_checksum_method_mlsmemberffi_get_index() != 31214) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mls_rs_uniffi_ios_checksum_method_mlsmemberffi_get_signing_identity() != 24712) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mls_rs_uniffi_ios_checksum_method_messageffi_epoch() != 46127) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mls_rs_uniffi_ios_checksum_method_messageffi_group_id() != 55497) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mls_rs_uniffi_ios_checksum_method_messageffi_private_message_content_type() != 62397) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mls_rs_uniffi_ios_checksum_method_messageffi_to_bytes() != 47388) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mls_rs_uniffi_ios_checksum_method_messageffi_unchecked_auth_data() != 55172) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mls_rs_uniffi_ios_checksum_method_messageffi_wire_format() != 23577) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mls_rs_uniffi_ios_checksum_method_signingidentityffi_basic_credential() != 49478) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mls_rs_uniffi_ios_checksum_method_signingidentityffi_node_signing_key() != 31789) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mls_rs_uniffi_ios_checksum_constructor_clientffi_new() != 42020) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mls_rs_uniffi_ios_checksum_constructor_messageffi_new() != 16017) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mls_rs_uniffi_ios_checksum_constructor_signingidentityffi_new() != 10612) {
        return InitializationResult.apiChecksumMismatch
    }

    uniffiCallbackInitGroupStateStorageProtocol()
    uniffiCallbackInitIdentityProviderProtocol()
    uniffiCallbackInitKeyPackageStorageProtocol()
    return InitializationResult.ok
}()

// Make the ensure init function public so that other modules which have external type references to
// our types can call it.
public func uniffiEnsureMlsRsUniffiIosInitialized() {
    switch initializationResult {
    case .ok:
        break
    case .contractVersionMismatch:
        fatalError("UniFFI contract version mismatch: try cleaning and rebuilding your project")
    case .apiChecksumMismatch:
        fatalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
}

// swiftlint:enable all